<?php

/**
 * @file
 * Install, update and uninstall functions for the social_group module.
 */

use Drupal\block\BlockInterface;
use Drupal\Core\Cache\Cache;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Entity\Sql\DefaultTableMapping;
use Drupal\Core\Entity\Sql\SqlContentEntityStorage;
use Drupal\field\FieldStorageConfigInterface;
use Drupal\menu_link_content\Entity\MenuLinkContent;
use Drupal\user\Entity\Role;
use Drupal\views\ViewEntityInterface;
use Symfony\Component\Yaml\Yaml;
use Drupal\Core\Config\FileStorage;

/**
 * Implements hook_install().
 *
 * Perform actions related to the installation of social_group.
 */
function social_group_install() {
  // Grant the default permissions for this feature.
  user_role_grant_permissions(
    'verified',
    [
      'view group stream page',
      'view groups on my profile',
      'view groups on other profiles',
      'flag mute_group_notifications',
      'unflag mute_group_notifications',
    ]
  );
  user_role_grant_permissions(
    'contentmanager',
    [
      'view group stream page',
      'view groups on my profile',
      'view groups on other profiles',
      'bypass create group access',
      'manage all groups',
      'view node.event.field_content_visibility:group content',
      'view node.topic.field_content_visibility:group content',
      'view node.page.field_content_visibility:group content',
      'access group overview',
      'edit group types',
      'flag mute_group_notifications',
      'unflag mute_group_notifications',
    ]
  );
  user_role_grant_permissions(
    'sitemanager',
    [
      'view group stream page',
      'view groups on my profile',
      'view groups on other profiles',
      'bypass create group access',
      'manage all groups',
      'view node.event.field_content_visibility:group content',
      'view node.topic.field_content_visibility:group content',
      'view node.page.field_content_visibility:group content',
      'access group overview',
      'edit group types',
      'set social group settings',
      'flag mute_group_notifications',
      'unflag mute_group_notifications',
    ]
  );
  // Add menu items.
  $parents = \Drupal::entityTypeManager()->getStorage('menu_link_content')
    ->loadByProperties(['menu_name' => 'main', 'title' => 'Explore', 'expanded' => TRUE]);
  $parent = reset($parents);
  if ($parent !== FALSE) {
    MenuLinkContent::create([
      'title' => t('All groups'),
      'link' => ['uri' => 'internal:/all-groups'],
      'menu_name' => 'main',
      'expanded' => FALSE,
      'weight' => 20,
      'parent' => 'menu_link_content:' . $parent->uuid(),
    ])->save();
  }

  // Set the view mode to use when shown in activities.
  activity_creator_set_entity_view_mode('group', 'stream');
  activity_creator_set_entity_view_mode('group_content', 'activity');

  // Make sure the admin theme is not used when managing groups.
  $group_settings = \Drupal::configFactory()->getEditable('group.settings');
  $group_settings->set('use_admin_theme', FALSE);
  $group_settings->save();

  // Disable group nodes.
  $view = \Drupal::service('entity_type.manager')->getStorage('view')->load('group_nodes');
  if (!is_null($view)) {
    $view->setStatus(FALSE);
    $view->save();
  }

  // Set module weight.
  module_set_weight('social_group', 2);

  // Since we update group related permissions that touch node content we must
  // also rebuild the node access permissions.
  node_access_rebuild();
}

/**
 * Update the user admin view with our custom action.
 *
 * Action ID: 'social_group_add_members_to_group_action'.
 */
function _social_group_alter_admin_people_view(): void {
  $config = \Drupal::configFactory()->getEditable('views.view.user_admin_people');
  $selected_actions = $config->get('display.default.display_options.fields.views_bulk_operations_bulk_form.selected_actions');
  $selected_actions[] = [
    'action_id' => 'social_group_add_members_to_group_action',
  ];
  $config->set('display.default.display_options.fields.views_bulk_operations_bulk_form.selected_actions', $selected_actions);
  $config->save();
}

/**
 * Implements hook_update_dependencies().
 */
function social_group_update_dependencies() {
  // New config changes should run after the VBO module changes
  // the structure of views.
  $dependencies['social_group'][11001] = [
    'views_bulk_operations' => 8034,
  ];

  // New config changes should run after the VBO module changes
  // the structure of views.
  $dependencies['social_group'][11002] = [
    'views_bulk_operations' => 8034,
  ];

  // New config changes should run after the VBO module changes
  // the structure of views.
  $dependencies['social_group'][10202] = [
    'views_bulk_operations' => 8034,
  ];

  return $dependencies;
}

/**
 * Implements hook_update_last_removed().
 */
function social_group_update_last_removed() : int {
  return 8907;
}

/**
 * Add translations support for views with groups.
 */
function social_group_update_10201() {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('social_group', 'social_group_update_10201');

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * Update the configs in the database in accordance with the newest schema.
 */
function social_group_update_10301() {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('social_group', 'social_group_update_10301');

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * The Group Events view configuration update.
 */
function social_group_update_10302() {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('social_group', 'social_group_update_10302');

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * Import flag "Mute Group Notifications" configurations.
 */
function social_group_update_10303() {
  $configs = [
    'flag.flag.mute_group_notifications' => 'flag.flag.mute_group_notifications_10303',
  ];

  $config_storage = \Drupal::service('config.storage');
  $config_path = \Drupal::service('extension.list.module')->getPath('social_group') . '/config/static/';
  $source = new FileStorage($config_path);

  foreach ($configs as $origin_name => $update_name) {
    $config_storage->write($origin_name, $source->read($update_name));
  }
}

/**
 * Update the permissions for social_group.
 */
function social_group_update_10304() {
  $permissions = [
    'flag mute_group_notifications',
    'unflag mute_group_notifications',
  ];

  $roles = Role::loadMultiple();

  /** @var \Drupal\user\Entity\Role $role */
  foreach ($roles as $role) {
    if ($role->id() === 'anonymous') {
      continue;
    }

    user_role_grant_permissions($role->id(), $permissions);
  }
}

/**
 * Update User Groups view configurations.
 */
function social_group_update_10305() {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('social_group', 'social_group_update_10305');

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * Import exposed block filter configurations of User Groups view.
 */
function social_group_update_10306() {
  $configs = [
    'block.block.exposed_form_groups_page_user_groups' => 'block.block.exposed_form_groups_page_user_groups_10306',
  ];

  $config_storage = \Drupal::service('config.storage');
  $config_path = \Drupal::service('extension.list.module')->getPath('social_group') . '/config/static/';
  $source = new FileStorage($config_path);

  foreach ($configs as $origin_name => $update_name) {
    $config_storage->write($origin_name, $source->read($update_name));
  }
}

/**
 * Update view displays for Group.
 */
function social_group_update_10307() {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('social_group', __FUNCTION__);

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * Set the default group configuration for cross-posting settings.
 */
function social_group_update_10308() {
  // Removed as redundant.
}

/**
 * Update BEF filter in the User Groups view.
 */
function social_group_update_11001(): string {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('social_group', __FUNCTION__);

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * Update 'views.view.group_manage_members' after VBO module updates.
 */
function social_group_update_11002(array &$sandbox): void {
  $config_file = \Drupal::service('extension.list.module')->getPath('social_group') . '/config/static/views.view.group_manage_members_11002.yml';

  if (is_file($config_file)) {
    $settings = Yaml::parse((string) file_get_contents($config_file));
    if (is_array($settings)) {
      $config = \Drupal::configFactory()
        ->getEditable('views.view.group_manage_members');

      $config->setData($settings)->save(TRUE);
    }
  }
}

/**
 * The emptied hook.
 */
function social_group_update_11003(array &$sandbox): void {
  // Moved to separate sequential update hook.
  // @see: social_group_update_11005
}

/**
 * Change Rendering Language settings for Group Events (Group content) view.
 */
function social_group_update_11004(): string {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('social_group', __FUNCTION__);

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * Add 'social_group_add_members_to_group_action'.
 *
 * Update 'views.view.user_admin_people' after VBO module updates.
 */
function social_group_update_11005(): void {
  $config = \Drupal::configFactory()->getEditable('views.view.user_admin_people');
  $selected_actions = $config->get('display.default.display_options.fields.views_bulk_operations_bulk_form.selected_actions');
  // We have to check if action is already added.
  $action = array_search('social_group_add_members_to_group_action', array_column($selected_actions, 'action_id'), FALSE);
  // If action is not added we add it.
  if ($action === FALSE) {
    $selected_actions[] = [
      'action_id' => 'social_group_add_members_to_group_action',
    ];
    $config->set('display.default.display_options.fields.views_bulk_operations_bulk_form.selected_actions', $selected_actions);
    $config->save();
  }
}

/**
 * Update exposed filter button name.
 */
function social_group_update_11401(): string {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('social_group', __FUNCTION__);

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * Add sorting by "title" to "All groups" and "User groups" pages.
 */
function social_group_update_11901(): string {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('social_group', __FUNCTION__);

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * Disable revisions for groups.
 */
function social_group_update_11902(): void {
  // Removed as redundant.
}

/**
 * Cancel limit of outputted roles in views.view.group_manage_members.
 */
function social_group_update_12001(): string {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('social_group', __FUNCTION__);

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * Search for invalid permission(s) and remove them from existing roles.
 *
 * Permissions to check:
 * - "view node.book.field_content_visibility:group content".
 */
function social_group_update_12002(): void {
  $entity_type_manager = \Drupal::entityTypeManager();
  $all_permissions = array_keys(\Drupal::service('user.permissions')->getPermissions());
  /** @var \Drupal\user\RoleInterface[] $roles */
  $roles = $entity_type_manager->getStorage('user_role')->loadMultiple();

  $permissions_to_check = [
    'view node.book.field_content_visibility:group content',
  ];

  // If permission is not valid (is not on the list of all permissions),
  // we need to revoke it from all existing roles.
  foreach ($permissions_to_check as $permission_to_check) {
    if (!in_array($permission_to_check, $all_permissions)) {
      foreach ($roles as $role) {
        if ($role->hasPermission($permission_to_check)) {
          $role->revokePermission($permission_to_check);
          $role->save();
        }
      }
    }
  }
}

/**
 * Add sort identifier to exposed sorts.
 */
function social_group_update_12003(): string {
  /** @var \Drupal\update_helper\Updater $updater */
  $updater = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updater->executeUpdate('social_group', 'social_group_update_12003');

  // Output logged messages to related channel of update execution.
  return $updater->logger()->output();
}

/**
 * Update old group types to flexible groups.
 */
function social_group_update_13000() : void {
  // Allow platforms to opt out of the group migration, for example if they want
  // to build it themselves and take more scenario's into account than common
  // Open Social installations will have.
  if (\Drupal::state()->get("social_group_group_type_migration_opt_out", FALSE)) {
    \Drupal::logger("social_group")->info("Platform has opted out of group migration.");
    return;
  }

  // Make sure the flexible group is installed.
  \Drupal::service("module_installer")->install(["social_group_flexible_group"]);

  $group_type_mapping = [
    'public_group' => [
      'fields' => [
        'field_flexible_group_visibility' => ['public'],
        'field_group_allowed_visibility' => ['public', 'community', 'group'],
        'field_group_allowed_join_method' => ['direct'],
      ],
    ],
    'open_group' => [
      'fields' => [
        'field_flexible_group_visibility' => ['community'],
        'field_group_allowed_visibility' => ['community', 'group'],
        'field_group_allowed_join_method' => ['direct'],
      ],
    ],
    'closed_group' => [
      'fields' => [
        'field_flexible_group_visibility' => ['community'],
        'field_group_allowed_visibility' => ['group'],
        'field_group_allowed_join_method' => ['added'], // This can be 'request' depending on groups_field_data.allow_request
      ],
    ],
    'secret_group' => [
      'fields' => [
        'field_flexible_group_visibility' => ['members'],
        'field_group_allowed_visibility' => ['group'],
        'field_group_allowed_join_method' => ['added'],
      ],
    ],
  ];

  // If the secret group module isn't enabled we don't need to migrate secret
  // groups.
  if (!\Drupal::moduleHandler()->moduleExists("social_group_secret")) {
    unset($group_type_mapping["secret_group"]);
  }

  $database = \Drupal::database();
  $transaction = $database->startTransaction("group-type-migration");

  $group_storage = \Drupal::entityTypeManager()->getStorage("group");
  if (!$group_storage instanceof SqlContentEntityStorage) {
    \Drupal::logger("social_group")->error("Can not migrate group types for non-SQL storage back-ends.");
    return;
  }
  $group_table_mapping = $group_storage->getTableMapping();

  $group_base_table = $group_storage->getBaseTable();
  $group_revision_table = $group_storage->getRevisionTable();
  $group_data_table = $group_storage->getDataTable();
  $group_revision_data_table = $group_storage->getRevisionDataTable();
  assert($group_data_table !== FALSE, "The group entity type should support a data table.");
  assert($group_revision_table !== FALSE, "The group entity type should support revisions.");
  assert($group_revision_data_table !== FALSE, "The group entity type should support revision data.");

  $group_content_storage = \Drupal::entityTypeManager()->getStorage("group_content");
  if (!$group_content_storage instanceof SqlContentEntityStorage) {
    \Drupal::logger("social_group")->error("Can not migrate group types for non-SQL storage back-ends.");
    return;
  }
  $group_content_table_mapping = $group_content_storage->getTableMapping();

  $group_content_base_table = $group_content_storage->getBaseTable();
  $group_content_data_table = $group_content_storage->getDataTable();
  assert($group_content_data_table !== FALSE, "The group content entity should support a data table.");

  /** @var \Drupal\group\Plugin\GroupContentEnablerManagerInterface $group_content_enabler_manager */
  $group_content_enabler_manager = \Drupal::service("plugin.manager.group_content_enabler");
  /** @var array<string, string[]> $group_type_content_plugins */
  $group_type_content_plugins = $group_content_enabler_manager->getGroupTypePluginMap();
  $group_type_content_plugin_replacement = [];

  // Ensure all plugins for our old group types are supported in flexible groups.
  foreach (array_keys($group_type_mapping) as $old_group_type) {
    $missing_plugins = array_diff($group_type_content_plugins[$old_group_type], $group_type_content_plugins["flexible_group"]);
    if (count($missing_plugins) !== 0) {
      throw new \Exception("Flexible group does not support plugins needed for $old_group_type: " . join(", ", $missing_plugins));
    }

    foreach ($group_type_content_plugins[$old_group_type] as $plugin_name) {
      $old_id = $old_group_type . '-' . str_replace(':', '-', $plugin_name);
      $new_id = "flexible_group" . '-' . str_replace(':', '-', $plugin_name);

      // Return a hashed ID if the readable ID would exceed the maximum length.
      if (strlen($old_id) > EntityTypeInterface::BUNDLE_MAX_LENGTH) {
        $hashed_id = 'group_content_type_' . md5($old_id);
        $old_id = substr($hashed_id, 0, EntityTypeInterface::BUNDLE_MAX_LENGTH);
      }
      if (strlen($new_id) > EntityTypeInterface::BUNDLE_MAX_LENGTH) {
        $hashed_id = 'group_content_type_' . md5($new_id);
        $new_id = substr($hashed_id, 0, EntityTypeInterface::BUNDLE_MAX_LENGTH);
      }

      $group_type_content_plugin_replacement[$old_group_type][$old_id] = $new_id;
    }
  }

  // Ensure all roles for our old groups exist for flexible groups.
  /** @var \Drupal\group\Entity\Storage\GroupRoleStorageInterface $group_role_storage */
  $group_roles = \Drupal::entityTypeManager()->getStorage("group_role")->loadMultiple();
  $group_roles_by_type = [];
  foreach ($group_roles as $group_role_id => $role) {
    foreach ([...array_keys($group_type_mapping), "flexible_group"] as $group_type) {
      if (str_starts_with($group_role_id, "$group_type-")) {
        $group_roles_by_type[$group_type][] = str_replace("$group_type-", "", $group_role_id);
        break;
      }
    }
  }
  foreach (array_keys($group_type_mapping) as $old_group_type) {
    $missing_roles = array_diff($group_roles_by_type[$old_group_type], $group_roles_by_type["flexible_group"]);
    if (count($missing_roles) !== 0) {
      throw new \Exception("Flexible group does not support roles needed for $old_group_type: " . join(", ", $missing_roles));
    }
  }

  $fsc_storage = \Drupal::entityTypeManager()->getStorage("field_storage_config");

  // Ensure all fields used on the old group types are available on
  // flexible_groups too.
  $missing_fields = [];
  /** @var \Drupal\Core\Entity\EntityFieldManagerInterface $entity_field_manager */
  $entity_field_manager = \Drupal::service('entity_field.manager');
  $flexible_group_fields = array_keys($entity_field_manager->getFieldDefinitions('group', 'flexible_group'));
  foreach (array_keys($group_type_mapping) as $old_group_type) {
    $missing_fields[] = array_keys($entity_field_manager->getFieldDefinitions('group', $old_group_type));
  }
  $missing_fields = array_diff(array_unique(array_merge(...$missing_fields)), $flexible_group_fields);
  if (count($missing_fields) > 0) {
    throw new \Exception("Flexible group is missing the following fields which are present on one of the old group types, remove them from the old group types or create them on flexible_group: " . join(", ", $missing_fields));
  }

  try {
    // @todo If the "require group types" setting is set then we should probably
    //   make sure the group type taxonomy terms exist and use those in the
    //   migration.

    // The below code transfers our visibility and access settings from the old
    // group types to the new group types. Those access settings are stored in
    // fields on the flexible group bundle. The mapping is provided above.
    // We work based on the group revision table to ensure that the data in the
    // database is consistent. The group type is not revisionable but is
    // constant throughout it's lifetime (from a group module perspective), so
    // when we change the group type we must pretend it always had that type.
    foreach ($group_type_mapping as $group_type => $mapping) {
      foreach ($mapping['fields'] as $field_name => $field_values) {
        $field_storage = $fsc_storage->load("group.$field_name");
        assert($field_storage instanceof FieldStorageConfigInterface, "Missing group field $field_name");
        foreach ($group_table_mapping->getAllFieldTableNames($field_name) as $tableName) {
          foreach ($field_values as $delta => $value) {
            // Revision tables need all revisions with an extra inner select.
            if (str_contains($tableName, "_revision__") || str_contains($tableName, "_r__")) {
              $group_id_query = $database->select($group_base_table, "group");
              $group_id_query->addField("group", "id", "id");
              $group_id_query->condition("type", $group_type);

              $from = $database->select($group_revision_table, "from");
              $from->condition("id", $group_id_query, "IN");
            }
            // Normal value tables only have the latest value.
            else {
              $from = $database->select($group_base_table, "from");
              $from->condition("type", $group_type);
            }

            $from->addField("from", "revision_id");
            $from->addField("from", "id", "entity_id");
            $from->addField("from", "langcode", "langcode");
            $from->addExpression("'flexible_group'", "bundle");
            $from->addExpression($delta, "delta");
            $from->addExpression("'$value'", $group_table_mapping->getFieldColumnName($field_storage, "value"));

            $database->insert($tableName)
              ->from($from)
              ->execute();
          }
        }
      }

      // The below code maps all the field data from the old group types to
      // flexible_groups except for the mapped fields related to visibility
      // which required inserting values. We again pretend the group type was
      // the same regardless of any revisioning.
      foreach ($entity_field_manager->getFieldDefinitions('group', $group_type) as $field_name => $definition) {
        // We only care about fieldable fields because the other fields are
        // stored in the base table.
        if ($definition->getFieldStorageDefinition()->isBaseField()) {
          continue;
        }
        // Skip visibility fields which we set to pre-determined values in a
        // previous query. Open Social should not have these fields on the old
        // group types and we don't support installs adding them manually.
        if (array_key_exists($field_name, $mapping['fields'])) {
          continue;
        }

        $field_storage = $fsc_storage->load("group.$field_name");
        assert($field_storage instanceof FieldStorageConfigInterface, "Missing group storage for field $field_name");
        foreach ($group_table_mapping->getAllFieldTableNames($field_name) as $tableName) {
          $database
            ->update($tableName)
            ->fields(['bundle' => "flexible_group"])
            ->condition("bundle", $group_type)
            ->execute();
        }
      }

      // Map all the group content plugins to their flexible_group counterpart.
      foreach ($group_type_content_plugin_replacement[$group_type] as $old_id => $new_id) {
        $database
          ->update($group_content_base_table)
          ->fields(["type" => $new_id])
          ->condition("type", $old_id)
          ->execute();

        $database
          ->update($group_content_data_table)
          ->fields(["type" => $new_id])
          ->condition("type", $old_id)
          ->execute();

        foreach ($group_content_table_mapping->getTableNames() as $tableName) {
          // Skip tables with a different field name we already had.
          if ($tableName === $group_content_base_table || $tableName === $group_content_data_table) {
            continue;
          }

          $database
            ->update($tableName)
            ->fields(["bundle" => $new_id])
            ->condition("bundle",  $old_id)
            ->execute();
        }
      }

      // Map all the group roles to the flexible group counterpart.
      $group_role_field_storage = $fsc_storage->load("group_content.group_roles");
      assert($group_role_field_storage instanceof FieldStorageConfigInterface, "Missing group content field group_roles");
      $group_role_column_name = $group_content_table_mapping->getFieldColumnName($group_role_field_storage, "target_id");
      foreach ($group_content_table_mapping->getAllFieldTableNames("group_roles") as $tableName) {
        foreach ($group_roles_by_type[$group_type] as $role) {
          $database
            ->update($tableName)
            ->fields([$group_role_column_name => "flexible_group-$role"])
            ->condition($group_role_column_name, "$group_type-$role")
            ->execute();
        }
      }
    }

    // Insert 1 into group__field_group_posts_enabled / group_revision__field_group_posts_enabled
    $posts_enabled_field_storage = $fsc_storage->load("group.field_group_posts_enabled");
    assert($posts_enabled_field_storage instanceof FieldStorageConfigInterface);
    foreach ($group_table_mapping->getAllFieldTableNames("field_group_posts_enabled") as $tableName) {
      // Revision tables need all revisions with an extra inner select.
      if (str_contains($tableName, "_revision__") || str_contains($tableName, "_r__")) {
        $group_id_query = $database->select($group_base_table, "group");
        $group_id_query->addField("group", "id", "id");
        $group_id_query->condition("type", array_keys($group_type_mapping), "IN");

        $from = $database->select($group_revision_table, "from");
        $from->condition("id", $group_id_query, "IN");
      }
      // Normal value tables only have the latest value.
      else {
        $from = $database->select($group_base_table, "from");
        $from->condition("type", array_keys($group_type_mapping), "IN");
      }

      $from->addField("from", "revision_id");
      $from->addField("from", "id", "entity_id");
      $from->addField("from", "langcode", "langcode");
      $from->addExpression("'flexible_group'", "bundle");
      $from->addExpression(0, "delta");
      $from->addExpression(1, $group_table_mapping->getFieldColumnName($posts_enabled_field_storage, "value"));

      $revision_id_query = $database->select($group_revision_data_table, "revision_data");
      $revision_id_query->addField("revision_data", "revision_id", "revision_id");
      $revision_id_query->condition("id", $group_id_query, "IN");

      $database->insert($tableName)
        ->from($from)
        ->execute();
    }

    // There's a base `allow_request` field that affects the value "field_group_allowed_join_method" for closed groups.
    $join_method_field_storage = $fsc_storage->load("group.field_group_allowed_join_method");
    assert($join_method_field_storage instanceof FieldStorageConfigInterface);
    foreach ($group_table_mapping->getAllFieldTableNames("field_group_allowed_join_method") as $tableName) {
      $group_id_query = $database->select($group_base_table, "group");
      $group_id_query->addField("group", "id", "id");
      $group_id_query->condition("type", "closed_group");

      $revision_id_query = $database->select($group_revision_data_table, "revision_data");
      $revision_id_query->addField("revision_data", "revision_id", "revision_id");
      $revision_id_query->condition("id", $group_id_query, "IN");
      $revision_id_query->condition("allow_request", 1);

      $database->update($tableName)
        ->condition("revision_id", $revision_id_query, "IN")
        ->condition($group_table_mapping->getFieldColumnName($join_method_field_storage, "value"), "added")
        ->fields([
          $group_table_mapping->getFieldColumnName($join_method_field_storage, "value") => "request",
        ])
        ->execute();
    }

    // Change the actual types of the group now that all the dependent data is
    // completed.
    \Drupal::database()->update($group_base_table)
      ->fields(['type' => "flexible_group"])
      ->condition("type", array_keys($group_type_mapping), "IN")
      ->execute();
    \Drupal::database()->update($group_data_table)
      ->fields(['type' => "flexible_group"])
      ->condition("type", array_keys($group_type_mapping), "IN")
      ->execute();
  }
  catch (\Exception $e) {
    $transaction->rollBack();
    throw $e;
  }

  // Commit our group-type-migration transaction.
  unset($transaction);

  // We must clear the entity caches in case other update hooks want to load
  // groups or group content. Changes that were done directly in the database
  // don't go through the Entity API to clear caches normally.
  \Drupal::service('cache.entity')->deleteAll();
  \Drupal::service('entity.memory_cache')->deleteAll();
}

/**
 * Uninstall old group types.
 */
function social_group_update_13001() : void {
  // Allow platforms to opt out of the group migration, for example if they want
  // to build it themselves and take more scenario's into account than common
  // Open Social installations will have.
  if (\Drupal::state()->get("social_group_group_type_migration_opt_out", FALSE)) {
    \Drupal::logger("social_group")->info("Platform has opted out of group migration.");
    return;
  }

  // Uninstall the secret group module if enabled.
  // This should take care of removing everything from secret group.
  \Drupal::service("module_installer")->uninstall(["social_secret_group_featured", "social_group_secret"]);

  // Delete our old group types.
  $group_type_storage = \Drupal::entityTypeManager()
    ->getStorage("group_type");
  foreach ($group_type_storage->loadMultiple(["closed_group", "open_group", "public_group"]) as $group_type) {
    $group_type->delete();
  }
}

/**
 * Remove deprecated group types.
 */
function social_group_update_13002(): ?string {
  // Allow platforms to opt out of the group migration, for example if they want
  // to build it themselves and take more scenario's into account than common
  // Open Social installations will have.
  if (\Drupal::state()->get('social_group_group_type_migration_opt_out', FALSE)) {
    \Drupal::logger('social_group')->info('Platform has opted out of group migration.');
    return NULL;
  }

  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('social_group', __FUNCTION__);

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * Clean up any group migration opt-out that might be enabled.
 */
function social_group_update_13003() : void {
  \Drupal::state()->delete("social_group_group_type_migration_opt_out");
}
