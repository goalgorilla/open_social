<?php

/**
 * @file
 * Install, update and uninstall functions for the social_group module.
 */

use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Entity\Sql\SqlContentEntityStorage;
use Drupal\field\FieldStorageConfigInterface;
use Drupal\menu_link_content\Entity\MenuLinkContent;

/**
 * Implements hook_install().
 *
 * Perform actions related to the installation of social_group.
 */
function social_group_install() {
  // Grant the default permissions for this feature.
  user_role_grant_permissions(
    'verified',
    [
      'view group stream page',
      'view groups on my profile',
      'view groups on other profiles',
      'flag mute_group_notifications',
      'unflag mute_group_notifications',
    ]
  );
  user_role_grant_permissions(
    'contentmanager',
    [
      'view group stream page',
      'view groups on my profile',
      'view groups on other profiles',
      'bypass create group access',
      'manage all groups',
      'view node.event.field_content_visibility:group content',
      'view node.topic.field_content_visibility:group content',
      'view node.page.field_content_visibility:group content',
      'access group overview',
      'edit group types',
      'flag mute_group_notifications',
      'unflag mute_group_notifications',
    ]
  );
  user_role_grant_permissions(
    'sitemanager',
    [
      'view group stream page',
      'view groups on my profile',
      'view groups on other profiles',
      'bypass create group access',
      'manage all groups',
      'view node.event.field_content_visibility:group content',
      'view node.topic.field_content_visibility:group content',
      'view node.page.field_content_visibility:group content',
      'access group overview',
      'edit group types',
      'set social group settings',
      'flag mute_group_notifications',
      'unflag mute_group_notifications',
    ]
  );
  // Add menu items.
  $parents = \Drupal::entityTypeManager()->getStorage('menu_link_content')
    ->loadByProperties(['menu_name' => 'main', 'title' => 'Explore', 'expanded' => TRUE]);
  $parent = reset($parents);
  if ($parent !== FALSE) {
    MenuLinkContent::create([
      'title' => t('All groups'),
      'link' => ['uri' => 'internal:/all-groups'],
      'menu_name' => 'main',
      'expanded' => FALSE,
      'weight' => 20,
      'parent' => 'menu_link_content:' . $parent->uuid(),
    ])->save();
  }

  // Set the view mode to use when shown in activities.
  activity_creator_set_entity_view_mode('group', 'stream');
  activity_creator_set_entity_view_mode('group_content', 'activity');

  // Make sure the admin theme is not used when managing groups.
  $group_settings = \Drupal::configFactory()->getEditable('group.settings');
  $group_settings->set('use_admin_theme', FALSE);
  $group_settings->save();

  // Disable group nodes.
  $view = \Drupal::service('entity_type.manager')->getStorage('view')->load('group_nodes');
  if (!is_null($view)) {
    $view->setStatus(FALSE);
    $view->save();
  }

  // Set module weight.
  module_set_weight('social_group', 2);

  // Since we update group related permissions that touch node content we must
  // also rebuild the node access permissions.
  node_access_rebuild();
}

/**
 * Implements hook_update_last_removed().
 * Function to set permissions.
 */
function _social_group_set_permissions() {
  $roles = Role::loadMultiple();

  /** @var \Drupal\user\Entity\Role $role */
  foreach ($roles as $role) {
    if ($role->id() === 'administrator') {
      continue;
    }

    $permissions = _social_group_get_permissions($role->id());
    user_role_grant_permissions($role->id(), $permissions);
  }
}

/**
 * Build the permissions.
 *
 * @param string $role
 *   The role.
 *
 * @return array
 *   Returns an array containing the permissions.
 */
function _social_group_get_permissions($role) {
  // Anonymous.
  $permissions[RoleInterface::ANONYMOUS_ID] = [
    'access group search',
  ];

  // Authenticated.
  $permissions[RoleInterface::AUTHENTICATED_ID] = array_merge($permissions[RoleInterface::ANONYMOUS_ID], []);

  // Verified.
  $permissions['verified'] = array_merge($permissions[RoleInterface::AUTHENTICATED_ID], [
    'create open_group group',
    'create closed_group group',
    'view group stream page',
    'view groups on my profile',
    'view groups on other profiles',
    'create public_group group',
    'flag mute_group_notifications',
    'unflag mute_group_notifications',
  ]);

  $config = \Drupal::config('entity_access_by_field.settings');
  $disable_public_visibility = $config->get('disable_public_visibility');
  if ($disable_public_visibility === 0) {
    $permissions['verified'][] = 'create public_group group';
  }

  // Content manager.
  $permissions['contentmanager'] = array_merge($permissions['verified'], [
    'bypass create group access',
    'manage all groups',
    'view node.event.field_content_visibility:group content',
    'view node.topic.field_content_visibility:group content',
    'view node.page.field_content_visibility:group content',
    'access group overview',
    'edit group types',
    'access cross-group posting',
  ]);

  // Site manager.
  $permissions['sitemanager'] = array_merge($permissions['contentmanager'], [
    'set social group settings',
  ]);

  if (isset($permissions[$role])) {
    return $permissions[$role];
  }
  return [];
}

/**
 * Update the user admin view with our custom action.
 *
 * Action ID: 'social_group_add_members_to_group_action'.
 */
function _social_group_alter_admin_people_view(): void {
  $config = \Drupal::configFactory()->getEditable('views.view.user_admin_people');
  $selected_actions = $config->get('display.default.display_options.fields.views_bulk_operations_bulk_form.selected_actions');
  $selected_actions[] = [
    'action_id' => 'social_group_add_members_to_group_action',
  ];
  $config->set('display.default.display_options.fields.views_bulk_operations_bulk_form.selected_actions', $selected_actions);
  $config->save();
}

/**
 * Install geolocation, geocoder and grolesync module.
 */
function social_group_update_8001() {

  $modules = [
    'geolocation',
    'geocoder',
    'grolesync',
  ];
  \Drupal::service('module_installer')->install($modules);

}

/**
 * Make sure the group nodes view is disabled.
 */
function social_group_update_8002() {
  $view = \Drupal::service('entity_type.manager')->getStorage('view')->load('group_nodes');
  if (!is_null($view)) {
    $view->setStatus(FALSE);
    $view->save();
  }
}

/**
 * Converts group description field type from plain text to formatted text.
 */
function social_group_update_8004(&$sandbox) {
  $entity = 'group';
  $bundle = 'open_group';
  $field_name = 'field_group_description';
  $display_mode = 'default';

  // Add a new column 'format' for description field type.
  $spec = [
    'type' => 'varchar',
    'description' => '',
    'length' => 255,
    'not null' => FALSE,
    'default' => NULL,
  ];
  $schema = Database::getConnection()->schema();
  $table = "{$entity}__{$field_name}";
  $col = "{$field_name}_format";
  $schema->addField($table, $col, $spec);

  // Update the field storage settings.
  $field_storage_id = "{$entity}.$field_name";
  $field_storage = \Drupal::entityTypeManager()->getStorage('field_storage_config')->load($field_storage_id);

  // Since the usual workflow for field storages do not allow changing the
  // field type, we have to work around it in this case.
  $new_field_storage = $field_storage->toArray();
  $new_field_storage['type'] = 'text_long';
  $new_field_storage['module'] = 'text';
  $new_field_storage['settings'] = [];
  $new_field_storage['dependencies']['module'][] = 'text';
  $new_field_storage = FieldStorageConfig::create($new_field_storage);
  $new_field_storage->original = $new_field_storage;
  $new_field_storage->enforceIsNew(FALSE);
  $new_field_storage->save();

  // Update the field settings.
  $field_id = "{$entity}.{$bundle}.$field_name";
  /** @var \Drupal\field\Entity\FieldConfig $field */
  $field = \Drupal::entityTypeManager()->getStorage('field_config')->load($field_id);
  $new_field = $field->toArray();
  $new_field['field_type'] = 'text_long';
  $new_field['dependencies']['module'][] = 'text';
  $new_field = FieldConfig::create($new_field);
  $new_field->original = $field;
  $new_field->enforceIsNew(FALSE);
  $new_field->save();

  // Update entity view display.
  $display_id = "{$entity}.{$bundle}.$display_mode";
  $view_display = \Drupal::service('entity_type.manager')->getStorage('entity_view_display')->load($display_id);
  if ($component = $view_display->getComponent($field_name)) {
    $view_display->setComponent($field_name, [
      'type' => 'basic_string',
      'settings' => [],
    ] + $component)->save();
  }

  // Update entity form display.
  $form_display_name = 'group.open_group.default';
  $form_display = \Drupal::entityTypeManager()->getStorage('entity_form_display')->load($form_display_name);
  if (($component = $form_display->getComponent($field_name)) && $component['type'] == 'string_textarea') {
    $form_display->setComponent($field_name, [
      'type' => 'text_textarea',
      'settings' => [
        'rows' => 5,
        'placeholder' => '',
      ],
    ] + $component)->save();
  }
}

/**
 * Uninstall geocoder and geolocation modules. Remove group geolocation field.
 */
function social_group_update_8005() {
  $modules = [
    'geolocation',
    'geocoder',
  ];

  $config_factory = \Drupal::service('config.factory');

  foreach ($modules as $module) {
    // Remove config.
    $config_factory->getEditable("$module.settings")->delete();

    // Remove cache tables.
    if (Database::getConnection()->schema()->tableExists("cache_$module")) {
      Database::getConnection()->schema()->dropTable("cache_$module");
    }

    // Remove data from system.schema.
    $query = \Drupal::database()->delete('key_value');
    $query->condition('name', $module);
    $query->execute();
  }

  // Remove group geolocation field.
  $config_factory->getEditable('field.field.group.closed_group.field_group_geolocation')->delete();
  $config_factory->getEditable('field.field.group.open_group.field_group_geolocation')->delete();
  $config_factory->getEditable('field.storage.group.field_group_geolocation')->delete();

  // Uninstall geocoder and geolocation modules.
  \Drupal::service('module_installer')->uninstall($modules);
}

/**
 * Add 'closed_group' group type and enable the permission for Authenticated.
 */
function social_group_update_8006() {
  $permissions = _social_group_get_permissions('authenticated');
  user_role_grant_permissions('authenticated', $permissions);
}

/**
 * Uninstall grolesync module (for now, more info: drupal.org/node/2850417).
 */
function social_group_update_8007() {
  $modules = ['grolesync'];
  \Drupal::service('module_installer')->uninstall($modules);
}

/**
 * Update the permissions for social_group.
 */
function social_group_update_8008() {
  _social_group_set_permissions();
}

/**
 * Set the default group configuration and permission for sitemanager.
 */
function social_group_update_8009() {
  $config = \Drupal::configFactory()->getEditable('social_group.settings');
  $config->set('allow_group_selection_in_node', FALSE);
  $config->save();

  // Site manager should have permission to set social group settings.
  $roles = Role::loadMultiple();

  /** @var \Drupal\user\Entity\Role $role */
  foreach ($roles as $role) {
    if ($role->id() !== 'sitemanager') {
      continue;
    }

    $permissions = ['set social group settings'];
    user_role_grant_permissions($role->id(), $permissions);
  }

}

/**
 * Add permissions for public groups.
 */
function social_group_update_8010() {
  /** @var \Drupal\user\Entity\Role $role */
  foreach (Role::loadMultiple() as $role) {
    if ($role->id() === 'anonymous') {
      user_role_grant_permissions($role->id(), ['access group search']);
    }
    else {
      user_role_grant_permissions($role->id(), [
        'create public_group group',
      ]);
    }
  }
}

/**
 * Rebuild node access.
 */
function social_group_update_8011() {
  node_access_rebuild(TRUE);
}

/**
 * Set module weight.
 */
function social_group_update_8012() {
  module_set_weight('social_group', 2);
}

/**
 * Set my groups permissions.
 */
function social_group_update_8013() {
  // Make it so that everyone who has the 'access user profiles' permission,
  // now also get these two new permissions.
  $permissions = [
    'view groups on my profile',
    'view groups on other profiles',
  ];

  /** @var \Drupal\user\Entity\Role $role */
  foreach (Role::loadMultiple() as $role) {
    if ($role->hasPermission('access user profiles')) {
      user_role_grant_permissions($role->id(), $permissions);
    }
  }
}

/**
 * Grant permission to access group overview to contentmanager and sitemanager.
 */
function social_group_update_8014() {
  user_role_grant_permissions('contentmanager', ['access group overview']);
  user_role_grant_permissions('sitemanager', ['access group overview']);
}

/**
 * NOTE: Contains possible data alteration!
 *
 * Change the visibility of all posts placed in an open group, which have
 * visibility public, to community.
 * See: https://www.drupal.org/project/social/issues/2992332#comment-12790905.
 */
function social_group_update_8301(&$sandbox) {
  if (!isset($sandbox['progress'])) {
    $sandbox['progress'] = 0;
    $sandbox['items'] = [];
    $sandbox['max'] = 0;

    // First grab all the post IDs that need to change.
    $connection = Database::getConnection();
    $sth = $connection->select('post__field_visibility', 'pv');
    $sth->fields('pv', ['entity_id']);
    $sth->join('post_field_data', 'pd', 'pd.id = pv.entity_id');
    $sth->join('post__field_recipient_group', 'pg', 'pv.entity_id = pg.entity_id');
    $sth->join('groups', 'g', 'pg.field_recipient_group_target_id = g.id');
    $sth->condition('pv.field_visibility_value', '1', '=');
    $sth->condition('g.type', 'open_group', '=');
    // Timestamp is from the moment the commit landed in 8.x-3.x see:
    // https://cgit.drupalcode.org/social/commit/?id=3e465bb1ad927712e22469c193b6e9547ba1c081
    $sth->condition('pd.created', '1534118400', '>');
    $data = $sth->execute();

    $sandbox['items']['post_ids'] = $data->fetchCol();
    $sandbox['max'] = count($sandbox['items']['post_ids']);
  }

  if ($sandbox['items']['post_ids']) {
    $pid = array_shift($sandbox['items']['post_ids']);

    // Load all the entities and re-save them with the correct visibility.
    $post = Post::load($pid);
    /** @var \Drupal\social_post\Entity\Post $post */
    $post->set('field_visibility', '0');
    $post->save();
  }

  $sandbox['progress']++;
  $sandbox['#finished'] = empty($sandbox['max']) ? 1 : ($sandbox['progress'] / $sandbox['max']);
}

/**
 * NOTE: Contains possible data alteration!
 *
 * Change the visibility of all nodes placed in an open group, which have
 * visibility public, to community.
 * See: https://www.drupal.org/project/social/issues/2992332#comment-12790905.
 */
function social_group_update_8302(&$sandbox) {
  if (!isset($sandbox['progress'])) {
    $sandbox['progress'] = 0;
    $sandbox['items'] = [];
    $sandbox['max'] = 0;

    // First grab all the node IDs that need to change.
    $connection = Database::getConnection();
    $sth = $connection->select('group_content_field_data', 'gc');
    $sth->fields('gc', ['entity_id']);
    $sth->join('node__field_content_visibility', 'nv', 'gc.entity_id = nv.entity_id');
    $sth->join('node_field_data', 'nd', 'gc.entity_id = nd.nid');
    $sth->condition('gc.type', 'open_group-group_node-%', 'LIKE');
    $sth->condition('nv.field_content_visibility_value', 'public', '=');
    // Timestamp is from the moment the commit landed in 8.x-3.x see:
    // https://cgit.drupalcode.org/social/commit/?id=3e465bb1ad927712e22469c193b6e9547ba1c081
    $sth->condition('nd.created', '1534118400', '>');
    $data = $sth->execute();

    $sandbox['items']['node_ids'] = $data->fetchCol();
    $sandbox['max'] = count($sandbox['items']['node_ids']);
  }

  if ($sandbox['items']['node_ids']) {
    $pid = array_shift($sandbox['items']['node_ids']);

    // Load all the entities and re-save them with the correct visibility.
    $node = Node::load($pid);
    /** @var \Drupal\node\Entity\Node $node */
    $node->set('field_content_visibility', 'community');
    $node->save();
  }

  $sandbox['progress']++;
  $sandbox['#finished'] = empty($sandbox['max']) ? 1 : ($sandbox['progress'] / $sandbox['max']);
}

/**
 * Grant permission to edit group types to contentmanager and sitemanager.
 */
function social_group_update_8303() {
  user_role_grant_permissions('contentmanager', ['edit group types']);
  user_role_grant_permissions('sitemanager', ['edit group types']);
}

/**
 * Install gvbo module.
 */
function social_group_update_8501() {
  $modules = ['gvbo', 'social_group_gvbo'];
  \Drupal::service('module_installer')->install($modules);
}

/**
 * Set some extra configuration.
 */
function social_group_update_8502() {
  $config = \Drupal::configFactory()->getEditable('social_group.settings');
  $config->set('allow_hero_selection', FALSE);
  $config->set('default_hero', 'hero');
  $config->save();
}

/**
 * Update view mode for new small teaser style.
 */
function social_group_update_8801() {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('social_group', 'social_group_update_8801');

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * Add new field for rendered profile entity so we can sort it.
 *
 * Load in a config file from an specific update hook that will never change.
 * Update helper did not update all fields correctly.
 */
function social_group_update_8802() {
  $config_file = \Drupal::service('extension.list.module')->getPath('social_group') . '/config/update/social_group_update_8802.yml';

  if (is_file($config_file)) {
    $settings = Yaml::parse(file_get_contents($config_file));
    if (is_array($settings)) {
      $config = \Drupal::configFactory()
        ->getEditable('views.view.group_manage_members');

      $config->setData($settings)->save(TRUE);
    }
  }
}

/**
 * Install Group Invite & Request modules by default.
 */
function social_group_update_8901() {
  $modules = ['social_group_invite', 'social_group_request'];
  \Drupal::service('module_installer')->install($modules);
}

/**
 * Update group's event views.
 */
function social_group_update_8902() {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('social_group', 'social_group_update_8803');

  // Update views configuration.
  _social_event_views_update('views.view.group_events', 'default');
}

/**
 * Allow creating groups by default.
 */
function social_group_update_8903() {
  $config = \Drupal::configFactory()->getEditable('social_group.settings');

  if (($setting = $config->get('address_visibility_settings')) !== NULL) {
    $config->set('address_visibility_settings', $setting['street_code_private']);
  }

  $config->set('allow_group_create', TRUE)->save();

  foreach (['contentmanager', 'sitemanager'] as $role) {
    user_role_grant_permissions($role, ['bypass create group access']);
  }
}

/**
 * Make sure flexible group, group type is not required by default.
 */
function social_group_update_8904() {
  $config = \Drupal::configFactory()->getEditable('social_group.settings');
  $config->set('social_group_type_required', FALSE)->save();
}

/**
 * Update form displays for group types according new 10.x UX design.
 */
function social_group_update_8905() {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('social_group', 'social_group_update_8905');

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * Make group creators as a group managers by default.
 */
function social_group_update_8906() {
  $config_factory = \Drupal::configFactory();

  $group_types = [
    'public_group',
    'open_group',
    'closed_group',
  ];

  foreach ($group_types as $group_type) {
    $config = $config_factory->getEditable('group.type.' . $group_type);
    $config->set('creator_membership', TRUE);

    $creator_roles = $config->get('creator_roles');
    $group_role_id = $group_type . '-group_manager';
    if (!in_array($group_role_id, $creator_roles)) {
      $creator_roles[] = $group_role_id;
      $config->set('creator_roles', $creator_roles);
    }

    $config->save(TRUE);
  }
}

/**
 * Add translation compatibility for Event fields and views.
 */
function social_group_update_8907() {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('social_group', 'social_group_update_8907');

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * Add translations support for views with groups.
 */
function social_group_update_10201() {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('social_group', 'social_group_update_10201');

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * Update the configs in the database in accordance with the newest schema.
 */
function social_group_update_10301() {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('social_group', 'social_group_update_10301');

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * The Group Events view configuration update.
 */
function social_group_update_10302() {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('social_group', 'social_group_update_10302');

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * Import flag "Mute Group Notifications" configurations.
 */
function social_group_update_last_removed() : int {
  return 11902;
}

/**
 * Cancel limit of outputted roles in views.view.group_manage_members.
 */
function social_group_update_12001(): string {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('social_group', __FUNCTION__);

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * Search for invalid permission(s) and remove them from existing roles.
 *
 * Permissions to check:
 * - "view node.book.field_content_visibility:group content".
 */
function social_group_update_12002(): void {
  $entity_type_manager = \Drupal::entityTypeManager();
  $all_permissions = array_keys(\Drupal::service('user.permissions')->getPermissions());
  /** @var \Drupal\user\RoleInterface[] $roles */
  $roles = $entity_type_manager->getStorage('user_role')->loadMultiple();

  $permissions_to_check = [
    'view node.book.field_content_visibility:group content',
  ];

  // If permission is not valid (is not on the list of all permissions),
  // we need to revoke it from all existing roles.
  foreach ($permissions_to_check as $permission_to_check) {
    if (!in_array($permission_to_check, $all_permissions)) {
      foreach ($roles as $role) {
        if ($role->hasPermission($permission_to_check)) {
          $role->revokePermission($permission_to_check);
          $role->save();
        }
      }
    }
  }
}

/**
 * Add sort identifier to exposed sorts.
 */
function social_group_update_12003(): string {
  /** @var \Drupal\update_helper\Updater $updater */
  $updater = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updater->executeUpdate('social_group', 'social_group_update_12003');

  // Output logged messages to related channel of update execution.
  return $updater->logger()->output();
}

/**
 * Enable pager limit on the manage members page.
 */
function social_group_update_12101(): string {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('social_group', __FUNCTION__);

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * Update old group types to flexible groups.
 */
function social_group_update_13000() : void {
  // Allow platforms to opt out of the group migration, for example if they want
  // to build it themselves and take more scenario's into account than common
  // Open Social installations will have.
  if (\Drupal::state()->get("social_group_group_type_migration_opt_out", FALSE)) {
    \Drupal::logger("social_group")->info("Platform has opted out of group migration.");
    return;
  }

  // Make sure the flexible group is installed.
  \Drupal::service("module_installer")->install(["social_group_flexible_group"]);

  $group_type_mapping = [
    'public_group' => [
      'fields' => [
        'field_flexible_group_visibility' => ['public'],
        'field_group_allowed_visibility' => ['public', 'community', 'group'],
        'field_group_allowed_join_method' => ['direct'],
      ],
    ],
    'open_group' => [
      'fields' => [
        'field_flexible_group_visibility' => ['community'],
        'field_group_allowed_visibility' => ['community', 'group'],
        'field_group_allowed_join_method' => ['direct'],
      ],
    ],
    'closed_group' => [
      'fields' => [
        'field_flexible_group_visibility' => ['community'],
        'field_group_allowed_visibility' => ['group'],
        // The join method can be 'request' depending on
        // groups_field_data.allow_request.
        'field_group_allowed_join_method' => ['added'],
      ],
    ],
    'secret_group' => [
      'fields' => [
        'field_flexible_group_visibility' => ['members'],
        'field_group_allowed_visibility' => ['group'],
        'field_group_allowed_join_method' => ['added'],
      ],
    ],
  ];

  // If the secret group module isn't enabled we don't need to migrate secret
  // groups.
  if (!\Drupal::moduleHandler()->moduleExists("social_group_secret")) {
    unset($group_type_mapping["secret_group"]);
  }

  $database = \Drupal::database();
  $transaction = $database->startTransaction("group-type-migration");

  $group_storage = \Drupal::entityTypeManager()->getStorage("group");
  if (!$group_storage instanceof SqlContentEntityStorage) {
    \Drupal::logger("social_group")->error("Can not migrate group types for non-SQL storage back-ends.");
    return;
  }
  $group_table_mapping = $group_storage->getTableMapping();

  $group_base_table = $group_storage->getBaseTable();
  $group_revision_table = $group_storage->getRevisionTable();
  $group_data_table = $group_storage->getDataTable();
  $group_revision_data_table = $group_storage->getRevisionDataTable();
  assert($group_data_table !== FALSE, "The group entity type should support a data table.");
  assert($group_revision_table !== FALSE, "The group entity type should support revisions.");
  assert($group_revision_data_table !== FALSE, "The group entity type should support revision data.");

  $group_content_storage = \Drupal::entityTypeManager()->getStorage("group_content");
  if (!$group_content_storage instanceof SqlContentEntityStorage) {
    \Drupal::logger("social_group")->error("Can not migrate group types for non-SQL storage back-ends.");
    return;
  }
  $group_content_table_mapping = $group_content_storage->getTableMapping();

  $group_content_base_table = $group_content_storage->getBaseTable();
  $group_content_data_table = $group_content_storage->getDataTable();
  assert($group_content_data_table !== FALSE, "The group content entity should support a data table.");

  /** @var \Drupal\group\Plugin\GroupContentEnablerManagerInterface $group_content_enabler_manager */
  $group_content_enabler_manager = \Drupal::service("plugin.manager.group_content_enabler");
  /** @var array<string, string[]> $group_type_content_plugins */
  $group_type_content_plugins = $group_content_enabler_manager->getGroupTypePluginMap();
  $group_type_content_plugin_replacement = [];

  // Ensure all old group type plugins are supported in flexible groups.
  foreach (array_keys($group_type_mapping) as $old_group_type) {
    $missing_plugins = array_diff(
      $group_type_content_plugins[$old_group_type],
      $group_type_content_plugins["flexible_group"]
    );
    if (count($missing_plugins) !== 0) {
      throw new \Exception("Flexible group does not support plugins needed for $old_group_type: " . implode(", ", $missing_plugins));
    }

    foreach ($group_type_content_plugins[$old_group_type] as $plugin_name) {
      $old_id = $old_group_type . '-' . str_replace(':', '-', $plugin_name);
      $new_id = "flexible_group" . '-' . str_replace(':', '-', $plugin_name);

      // Return a hashed ID if the readable ID would exceed the maximum length.
      if (strlen($old_id) > EntityTypeInterface::BUNDLE_MAX_LENGTH) {
        $hashed_id = 'group_content_type_' . md5($old_id);
        $old_id = substr($hashed_id, 0, EntityTypeInterface::BUNDLE_MAX_LENGTH);
      }
      if (strlen($new_id) > EntityTypeInterface::BUNDLE_MAX_LENGTH) {
        $hashed_id = 'group_content_type_' . md5($new_id);
        $new_id = substr($hashed_id, 0, EntityTypeInterface::BUNDLE_MAX_LENGTH);
      }

      $group_type_content_plugin_replacement[$old_group_type][$old_id] = $new_id;
    }
  }

  // Ensure all roles for our old groups exist for flexible groups.
  $group_roles = \Drupal::entityTypeManager()->getStorage("group_role")->loadMultiple();
  $group_roles_by_type = [];
  foreach ($group_roles as $group_role_id => $role) {
    foreach ([...array_keys($group_type_mapping), "flexible_group"] as $group_type) {
      if (str_starts_with($group_role_id, "$group_type-")) {
        $group_roles_by_type[$group_type][] = str_replace("$group_type-", "", $group_role_id);
        break;
      }
    }
  }
  foreach (array_keys($group_type_mapping) as $old_group_type) {
    $missing_roles = array_diff($group_roles_by_type[$old_group_type], $group_roles_by_type["flexible_group"]);
    if (count($missing_roles) !== 0) {
      throw new \Exception("Flexible group does not support roles needed for $old_group_type: " . implode(", ", $missing_roles));
    }
  }

  $fsc_storage = \Drupal::entityTypeManager()->getStorage("field_storage_config");

  // Ensure all fields used on the old group types are available on
  // flexible_groups too.
  $missing_fields = [];
  /** @var \Drupal\Core\Entity\EntityFieldManagerInterface $entity_field_manager */
  $entity_field_manager = \Drupal::service('entity_field.manager');
  $flexible_group_fields = array_keys($entity_field_manager->getFieldDefinitions('group', 'flexible_group'));
  foreach (array_keys($group_type_mapping) as $old_group_type) {
    $missing_fields[] = array_keys($entity_field_manager->getFieldDefinitions('group', $old_group_type));
  }
  $missing_fields = array_diff(array_unique(array_merge(...$missing_fields)), $flexible_group_fields);
  if (count($missing_fields) > 0) {
    throw new \Exception("Flexible group is missing the following fields which are present on one of the old group types, remove them from the old group types or create them on flexible_group: " . implode(", ", $missing_fields));
  }

  try {
    // @todo If the "require group types" setting is set then we should probably
    //   make sure the group type taxonomy terms exist and use those in the
    //   migration.
    // The below code transfers our visibility and access settings from the old
    // group types to the new group types. Those access settings are stored in
    // fields on the flexible group bundle. The mapping is provided above.
    // We work based on the group revision table to ensure that the data in the
    // database is consistent. The group type is not revisionable but is
    // constant throughout it's lifetime (from a group module perspective), so
    // when we change the group type we must pretend it always had that type.
    foreach ($group_type_mapping as $group_type => $mapping) {
      foreach ($mapping['fields'] as $field_name => $field_values) {
        $field_storage = $fsc_storage->load("group.$field_name");
        assert($field_storage instanceof FieldStorageConfigInterface, "Missing group field $field_name");
        foreach ($group_table_mapping->getAllFieldTableNames($field_name) as $tableName) {
          foreach ($field_values as $delta => $value) {
            // Revision tables need all revisions with an extra inner select.
            if (str_contains($tableName, "_revision__") || str_contains($tableName, "_r__")) {
              $group_id_query = $database->select($group_base_table, "group");
              $group_id_query->addField("group", "id", "id");
              $group_id_query->condition("type", $group_type);

              $from = $database->select($group_revision_table, "from");
              $from->condition("id", $group_id_query, "IN");
            }
            // Normal value tables only have the latest value.
            else {
              $from = $database->select($group_base_table, "from");
              $from->condition("type", $group_type);
            }

            $from->addField("from", "revision_id");
            $from->addField("from", "id", "entity_id");
            $from->addField("from", "langcode", "langcode");
            $from->addExpression("'flexible_group'", "bundle");
            $from->addExpression($delta, "delta");
            $from->addExpression("'$value'", $group_table_mapping->getFieldColumnName($field_storage, "value"));

            $database->insert($tableName)
              ->from($from)
              ->execute();
          }
        }
      }

      // The below code maps all the field data from the old group types to
      // flexible_groups except for the mapped fields related to visibility
      // which required inserting values. We again pretend the group type was
      // the same regardless of any revisions.
      foreach ($entity_field_manager->getFieldDefinitions('group', $group_type) as $field_name => $definition) {
        // We only care about fieldable fields because the other fields are
        // stored in the base table.
        if ($definition->getFieldStorageDefinition()->isBaseField()) {
          continue;
        }
        // Skip visibility fields which we set to pre-determined values in a
        // previous query. Open Social should not have these fields on the old
        // group types and we don't support installs adding them manually.
        if (array_key_exists($field_name, $mapping['fields'])) {
          continue;
        }

        $field_storage = $fsc_storage->load("group.$field_name");
        assert($field_storage instanceof FieldStorageConfigInterface, "Missing group storage for field $field_name");
        foreach ($group_table_mapping->getAllFieldTableNames($field_name) as $tableName) {
          $database
            ->update($tableName)
            ->fields(['bundle' => "flexible_group"])
            ->condition("bundle", $group_type)
            ->execute();
        }
      }

      // Map all the group content plugins to their flexible_group counterpart.
      foreach ($group_type_content_plugin_replacement[$group_type] as $old_id => $new_id) {
        $database
          ->update($group_content_base_table)
          ->fields(["type" => $new_id])
          ->condition("type", $old_id)
          ->execute();

        $database
          ->update($group_content_data_table)
          ->fields(["type" => $new_id])
          ->condition("type", $old_id)
          ->execute();

        foreach ($group_content_table_mapping->getTableNames() as $tableName) {
          // Skip tables with a different field name we already had.
          if ($tableName === $group_content_base_table || $tableName === $group_content_data_table) {
            continue;
          }

          $database
            ->update($tableName)
            ->fields(["bundle" => $new_id])
            ->condition("bundle", $old_id)
            ->execute();
        }
      }

      // Map all the group roles to the flexible group counterpart.
      $group_role_field_storage = $fsc_storage->load("group_content.group_roles");
      assert($group_role_field_storage instanceof FieldStorageConfigInterface, "Missing group content field group_roles");
      $group_role_column_name = $group_content_table_mapping->getFieldColumnName($group_role_field_storage, "target_id");
      foreach ($group_content_table_mapping->getAllFieldTableNames("group_roles") as $tableName) {
        foreach ($group_roles_by_type[$group_type] as $role) {
          $database
            ->update($tableName)
            ->fields([$group_role_column_name => "flexible_group-$role"])
            ->condition($group_role_column_name, "$group_type-$role")
            ->execute();
        }
      }
    }

    // Insert 1 into group__field_group_posts_enabled /
    // group_revision__field_group_posts_enabled.
    $posts_enabled_field_storage = $fsc_storage->load("group.field_group_posts_enabled");
    assert($posts_enabled_field_storage instanceof FieldStorageConfigInterface);
    foreach ($group_table_mapping->getAllFieldTableNames("field_group_posts_enabled") as $tableName) {
      // Revision tables need all revisions with an extra inner select.
      if (str_contains($tableName, "_revision__") || str_contains($tableName, "_r__")) {
        $group_id_query = $database->select($group_base_table, "group");
        $group_id_query->addField("group", "id", "id");
        $group_id_query->condition("type", array_keys($group_type_mapping), "IN");

        $from = $database->select($group_revision_table, "from");
        $from->condition("id", $group_id_query, "IN");
      }
      // Normal value tables only have the latest value.
      else {
        $from = $database->select($group_base_table, "from");
        $from->condition("type", array_keys($group_type_mapping), "IN");
      }

      $from->addField("from", "revision_id");
      $from->addField("from", "id", "entity_id");
      $from->addField("from", "langcode", "langcode");
      $from->addExpression("'flexible_group'", "bundle");
      $from->addExpression(0, "delta");
      $from->addExpression(1, $group_table_mapping->getFieldColumnName($posts_enabled_field_storage, "value"));

      $database->insert($tableName)
        ->from($from)
        ->execute();
    }

    // There's a base `allow_request` field that affects the value
    // "field_group_allowed_join_method" for closed groups.
    $join_method_field_storage = $fsc_storage->load("group.field_group_allowed_join_method");
    assert($join_method_field_storage instanceof FieldStorageConfigInterface);
    foreach ($group_table_mapping->getAllFieldTableNames("field_group_allowed_join_method") as $tableName) {
      $group_id_query = $database->select($group_base_table, "group");
      $group_id_query->addField("group", "id", "id");
      $group_id_query->condition("type", "closed_group");

      $revision_id_query = $database->select($group_revision_data_table, "revision_data");
      $revision_id_query->addField("revision_data", "revision_id", "revision_id");
      $revision_id_query->condition("id", $group_id_query, "IN");
      $revision_id_query->condition("allow_request", "1");

      $database->update($tableName)
        ->condition("revision_id", $revision_id_query, "IN")
        ->condition($group_table_mapping->getFieldColumnName($join_method_field_storage, "value"), "added")
        ->fields([
          $group_table_mapping->getFieldColumnName($join_method_field_storage, "value") => "request",
        ])
        ->execute();
    }

    // Change the actual types of the group now that all the dependent data is
    // completed.
    \Drupal::database()->update($group_base_table)
      ->fields(['type' => "flexible_group"])
      ->condition("type", array_keys($group_type_mapping), "IN")
      ->execute();
    \Drupal::database()->update($group_data_table)
      ->fields(['type' => "flexible_group"])
      ->condition("type", array_keys($group_type_mapping), "IN")
      ->execute();
  }
  catch (\Exception $e) {
    $transaction->rollBack();
    throw $e;
  }

  // Commit our group-type-migration transaction.
  unset($transaction);

  // We must clear the entity caches in case other update hooks want to load
  // groups or group content. Changes that were done directly in the database
  // don't go through the Entity API to clear caches normally.
  \Drupal::service('cache.entity')->deleteAll();
  \Drupal::service('entity.memory_cache')->deleteAll();
}

/**
 * Uninstall old group types.
 */
function social_group_update_13001() : void {
  // Allow platforms to opt out of the group migration, for example if they want
  // to build it themselves and take more scenario's into account than common
  // Open Social installations will have.
  if (\Drupal::state()->get("social_group_group_type_migration_opt_out", FALSE)) {
    \Drupal::logger("social_group")->info("Platform has opted out of group migration.");
    return;
  }

  // Uninstall the secret group module if enabled.
  // This should take care of removing everything from secret group.
  \Drupal::service("module_installer")->uninstall(["social_secret_group_featured", "social_group_secret"]);

  // Delete our old group types.
  $group_type_storage = \Drupal::entityTypeManager()
    ->getStorage("group_type");
  foreach ($group_type_storage->loadMultiple(["closed_group", "open_group", "public_group"]) as $group_type) {
    $group_type->delete();
  }
}

/**
 * Clean up any group migration opt-out that might be enabled.
 */
function social_group_update_13002() : void {
  \Drupal::state()->delete("social_group_group_type_migration_opt_out");
}

/**
 * Add a medium teaser view mode.
 */
function social_group_update_13003(): string {
  /** @var \Drupal\update_helper\Updater $updateHelper */
  $updateHelper = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updateHelper->executeUpdate('social_group', __FUNCTION__);

  // Output logged messages to related channel of update execution.
  return $updateHelper->logger()->output();
}

/**
 * Make group views independent of group types.
 */
function social_group_update_13004() : string {
  /** @var \Drupal\update_helper\Updater $updater */
  $updater = \Drupal::service('update_helper.updater');

  // Execute configuration update definitions with logging of success.
  $updater->executeUpdate('social_group', 'social_group_update_13004');

  // Output logged messages to related channel of update execution.
  return $updater->logger()->output();
}
