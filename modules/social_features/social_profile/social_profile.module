<?php

/**
 * @file
 * The Social profile module.
 */

use Drupal\block\Entity\Block;
use Drupal\Core\Access\AccessResult;
use Drupal\Core\Access\AccessResultInterface;
use Drupal\Core\Cache\Cache;
use Drupal\Core\Entity\Display\EntityFormDisplayInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Field\FieldItemInterface;
use Drupal\Core\Field\FieldDefinitionInterface;
use Drupal\Core\Field\FieldConfigInterface;
use Drupal\Core\Field\FieldItemListInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Link;
use Drupal\Core\Render\Element;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Session\AccountProxyInterface;
use Drupal\Core\StringTranslation\TranslatableMarkup;
use Drupal\Core\Url;
use Drupal\file\FileInterface;
use Drupal\field\Entity\FieldConfig;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\field\FieldStorageConfigInterface;
use Drupal\image\Entity\ImageStyle;
use Drupal\menu_link_content\MenuLinkContentInterface;
use Drupal\node\Entity\Node;
use Drupal\profile\Entity\Profile;
use Drupal\profile\Entity\ProfileInterface;
use Drupal\profile\Entity\ProfileType;
use Drupal\social_profile\FieldManager;
use Drupal\social_profile\Plugin\views\filter\SocialSearchApiSplitProfileTerms;
use Drupal\social_profile\SocialProfileUserFormAlter;
use Drupal\user\UserInterface;

const SOCIAL_PROFILE_SUGGESTIONS_USERNAME = 'username';
const SOCIAL_PROFILE_SUGGESTIONS_FULL_NAME = 'full_name';
const SOCIAL_PROFILE_SUGGESTIONS_ALL = 'all';

define('SOCIAL_PROFILE_FIELD_VISIBILITY_PUBLIC', 'public');
define('SOCIAL_PROFILE_FIELD_VISIBILITY_COMMUNITY', 'community');
// Open Social does not yet support friends but it's a logical step between
// private and community which is why the constant is already documented here.
define('SOCIAL_PROFILE_FIELD_VISIBILITY_FRIENDS', 'friends');
define('SOCIAL_PROFILE_FIELD_VISIBILITY_PRIVATE', 'private');

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function social_profile_field_storage_config_insert(FieldStorageConfigInterface $field_storage_config) : void {
  if ($field_storage_config->getTargetEntityTypeId() === "profile" && $field_storage_config->getThirdPartySetting('social_profile', 'visibility_for') === NULL) {
    $visibility_storage_config = social_profile_create_visibility_field_storage_config_for($field_storage_config);

    var_dump($visibility_storage_config->getName());
    $field_storage_config->setThirdPartySetting('social_profile', 'visibility_stored_by', $visibility_storage_config->getName());
    $field_storage_config->save();
  }
}

/**
 * Implements hook_ENTITY_TYPE_delete().
 */
function social_profile_field_storage_config_delete(FieldStorageConfigInterface $field_storage_config) : void {
  if ($field_storage_config->getTargetEntityTypeId() === "profile" && $field_storage_config->getThirdPartySetting('social_profile', 'visibility_stored_by') !== NULL) {
    social_profile_delete_visibility_field_storage_config_for($field_storage_config);
  }
}

/**
 * Create visibility field storage configuration for another field.
 *
 * @param \Drupal\field\FieldStorageConfigInterface $field_storage_config
 *   The field storage configuration for which to create the visibility field
 *   storage configuration.
 *
 * @return \Drupal\field\FieldStorageConfigInterface
 *   The created field storage config interface.
 */
function social_profile_create_visibility_field_storage_config_for(FieldStorageConfigInterface $field_storage_config) : FieldStorageConfigInterface {
  if ($field_storage_config->getThirdPartySetting('social_profile', 'visibility_for') !== NULL) {
    throw new RuntimeException("Can not create a visibility field storage config for another visibility field storage config, this could create loops.");
  }

  if ($field_storage_config->getThirdPartySetting('social_profile', 'visibility_stored_by') !== NULL) {
    throw new RuntimeException("Tried to create a visibility field storage config for a field that already has a visibility field storage config.");
  }

  /** @var \Drupal\field\FieldStorageConfigInterface $visibility_storage_config */
  $visibility_storage_config = FieldStorageConfig::create([
    'field_name' => social_profile_get_visibility_field_name($field_storage_config->getName()),
    'entity_type' => $field_storage_config->getTargetEntityTypeId(),
    'type' => 'list_string',
    'module' => 'social_profile',
    'translatable' => FALSE,
    'locked' => TRUE,
    'settings' => [
      'allowed_values_function' => 'social_profile_field_visibility_values',
    ],
  ]);
  $visibility_storage_config->setThirdPartySetting('social_profile', 'visibility_for', $field_storage_config->getName());
  $visibility_storage_config->save();

  return $visibility_storage_config;
}

/**
 * Delete visibility field storage configuration for another field.
 *
 * @param \Drupal\field\FieldStorageConfigInterface $field_storage_config
 *   The field storage configuration for which to delete the corresponding
 *   visibility field storage configuration.
 */
function social_profile_delete_visibility_field_storage_config_for(FieldStorageConfigInterface $field_storage_config) : void {
  if ($field_storage_config->getThirdPartySetting('social_profile', 'visibility_stored_by') === NULL) {
    throw new RuntimeException("Can not remove visibility field config storage for field without visibility field config storage.");
  }

  /** @var \Drupal\field\FieldStorageConfigInterface|null $visibility_storage_config */
  $visibility_storage_config = FieldStorageConfig::loadByName($field_storage_config->getTargetEntityTypeId(), $field_storage_config->getThirdPartySetting('social_profile', 'visibility_stored_by'));

  // If we can't load a visibility storage config then we're done.
  if ($visibility_storage_config !== NULL) {
    if ($visibility_storage_config->getThirdPartySetting('social_profile', 'visibility_for') !== $field_storage_config->getName()) {
      throw new RuntimeException("A field storage config indicated that its visibility was stored by a visibility field storage that was not intended for this field.");
    }

    $visibility_storage_config->delete();
  }

  // While slightly awkward for the API we can not save here since that may
  // restore a field storage config entity that is being deleted.
  $field_storage_config->setThirdPartySetting('social_profile', 'visibility_stored_by', NULL);
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function social_profile_field_config_insert(FieldConfigInterface $field_config) : void {
  social_profile_ensure_associated_visibility_field_config($field_config);
}

/**
 * Implements hook_ENTITY_TYPE_delete().
 */
function social_profile_field_config_delete(FieldConfigInterface $field_config) : void {
  social_profile_delete_associated_visibility_field_config($field_config);
}

/**
 * Ensures that a field config entity exists to mirror a profile field.
 *
 * When fields are created this adds the field config for the field storage that
 * is created elsewhere. This ensures an adjustable config entity exists for
 * each bundle where a field is added.
 *
 * @param \Drupal\Core\Field\FieldConfigInterface $field_config
 *   The field config of the field for which a visibility field config should be
 *   created.
 */
function social_profile_ensure_associated_visibility_field_config(FieldConfigInterface $field_config) : void {
  // We only support storage configs from the field module, not those in Drupal
  // core (i.e. entity base fields).
  $field_storage_config = $field_config->getFieldStorageDefinition();
  if (!$field_storage_config instanceof FieldStorageConfigInterface) {
    return;
  }

  // This only works for fieldable fields. Those are required to have a bundle.
  $bundle = $field_config->getTargetBundle();
  if ($bundle === NULL) {
    throw new \InvalidArgumentException("Field config ({$field_config->getName()}) requesting visibility field must be associated with a bundle.");
  }

  // Don't do anything when we're called for a field config that belongs to a
  // field storage that stores visibility information. That field config is
  // probably created by ourselves and would create infinite loops.
  if ($field_storage_config->getThirdPartySetting('social_profile', 'visibility_for') !== NULL) {
    return;
  }

  // Avoid trying to create a field config when there's no visibility storage
  // for the field that we're configuring visibility info for. This can happen
  // if a field has asked to opt-out of visibility configurability.
  $visibility_field_name = $field_storage_config->getThirdPartySetting('social_profile', 'visibility_stored_by');
  if ($visibility_field_name === NULL) {
    return;
  }

  $visibility_storage_config = FieldStorageConfig::loadByName($field_storage_config->getTargetEntityTypeId(), $visibility_field_name);
  if ($visibility_storage_config === NULL) {
    throw new RuntimeException("{$field_storage_config->getName()} indicated visibility storage in {$visibility_field_name} but that field has no storage entity.");
  }

  // Nothing to do if the visibility field config already exists.
  if (FieldConfig::loadByName($field_config->getTargetEntityTypeId(), $bundle, $visibility_storage_config->getName()) !== NULL) {
    return;
  }

  FieldConfig::create([
    'label' => new TranslatableMarkup("%field_name Visibility", ['%field_name' => $field_config->label()]),
    'field_name' => $visibility_field_name,
    'entity_type' => $field_config->getTargetEntityTypeId(),
    'bundle' => $bundle,
    'type' => 'list_string',
    'module' => 'social_profile',
    'translatable' => FALSE,
    'locked' => TRUE,
    'required' => TRUE,
    'settings' => [
      'allowed_values_function' => 'social_profile_field_visibility_values',
    ],
  ])->save();
}

/**
 * Remove the visibility field config for our managed field access.
 *
 * @param \Drupal\Core\Field\FieldConfigInterface $field_config
 *   The value field that is being removed for which to remove the matching
 *   visibility field config.
 */
function social_profile_delete_associated_visibility_field_config(FieldConfigInterface $field_config) : void {
  // We only support storage configs from the field module, not those in Drupal
  // core (i.e. entity base fields).
  $field_storage_config = $field_config->getFieldStorageDefinition();
  if (!$field_storage_config instanceof FieldStorageConfigInterface) {
    return;
  }

  // We only support fields for a bundle.
  $bundle = $field_config->getTargetBundle();
  if ($bundle === NULL) {
    throw new \InvalidArgumentException("Field config ({$field_config->getName()}) requesting visibility field must be associated with a bundle.");
  }

  // No need to delete an associated visibility field config if the deleted
  // field doesn't have one.
  $visibility_field_name = $field_storage_config->getThirdPartySetting('social_profile', 'visibility_stored_by');
  if ($visibility_field_name === NULL) {
    return;
  }

  $visibility_storage_config = FieldStorageConfig::loadByName($field_config->getTargetEntityTypeId(), $visibility_field_name);
  if ($visibility_storage_config === NULL) {
    throw new RuntimeException("{$field_storage_config->getName()} indicated visibility storage in {$visibility_field_name} but that storage does not exist.");
  }

  $visibility_config = FieldConfig::loadByName($field_config->getTargetEntityTypeId(), $bundle, $visibility_storage_config->getName());

  // Nothing to delete if it's already gone.
  if ($visibility_config === NULL) {
    return;
  }

  $visibility_config->delete();
}

/**
 * Generate the visibility field name.
 *
 * Field names need to be less than 32 characters but since we're deriving our
 * name from another field name we may already go over that by simply appending
 * another string to the name.
 *
 * @param string $field_name
 *   The name of the field to get the visibility field name for.
 *
 * @return string
 *   The name of the visibility field.
 */
function social_profile_get_visibility_field_name(string $field_name) : string {
  // We prefer just prepending our prefix.
  $visibility_name = 'visibility_' . $field_name;
  // But we must limit based on the FieldStorageConfig rules.
  if (mb_strlen($visibility_name) > FieldStorageConfig::NAME_MAX_LENGTH) {
    // In that case we borrow a trick from
    // \Drupal\Core\Entity\Sql\DefaultTableMapping::generateFieldTableName().
    $field_name_hash = substr(hash('sha256', $field_name), 0, 28);
    $visibility_name = "vis_" . $field_name_hash;
  }

  return $visibility_name;
}

/**
 * Provides the available allowed visibility values.
 *
 * The values available are not meant to be editable. However, using a value
 * function allows Open Social to add new allowed values (such as FRIENDS) in
 * the future without having to provide configuration updates for a lot of
 * fields.
 *
 * If you're thinking of adding a value here, please discuss with the core team
 * first. There may be other ways to achieve what you want.
 *
 * @return array
 *   The values allowed in visibility fields.
 */
function social_profile_field_visibility_values() : array {
  return [
    SOCIAL_PROFILE_FIELD_VISIBILITY_PUBLIC => new TranslatableMarkup("Public"),
    SOCIAL_PROFILE_FIELD_VISIBILITY_COMMUNITY => new TranslatableMarkup("Community"),
    SOCIAL_PROFILE_FIELD_VISIBILITY_PRIVATE => new TranslatableMarkup("Private"),
  ];
}

/**
 * Implements hook_field_widget_form_alter().
 */
function social_profile_field_widget_form_alter(&$element, FormStateInterface $form_state, $context) {
  /** @var \Drupal\Core\Field\FieldDefinitionInterface $field_definition */
  $field_definition = $context['items']->getFieldDefinition();
  switch ($field_definition->getName()) {
    case 'field_profile_phone_number':
      // @todo Remove this when rule for .form-tel elements will be added.
      $element['value']['#attributes']['class'][] = 'form-text';
      $element['value']['#attributes']['autocomplete'][] = 'tel';
      break;

    case 'field_profile_address':
      // @todo Remove this when script for custom selects will be added.
      $element['country_code']['#attributes']['class'][] = 'browser-default';
      break;

    // Alter how profiles are embedded within the user edit for.
    case 'profile_profiles':
      social_profile_user_form_profiles_field_alter($element, $form_state, $context);
      break;
  }

  if (FieldManager::isVisibilityField($field_definition)) {
    // The field is required but we don't want to display this for all fields.
    // The select element itself already enforces that a value is selected.
    $element['#required'] = FALSE;
  }

  // This replaces all user entity references with our EntityReferenceSelection.
  if ($field_definition->getType() === 'entity_reference') {
    if (
      isset($element['target_id']['#target_type']) &&
      $element['target_id']['#target_type'] === 'user' &&
      $element['target_id']['#type'] !== 'social_private_message_entity_autocomplete'
    ) {
      $element['target_id']['#selection_handler'] = 'social';
    }
  }
}

/**
 * Alter how an embedded profile form works in the user edit form.
 *
 * Not called as actual alter hook but called from the social profile widget
 * form alter.
 */
function social_profile_user_form_profiles_field_alter(array &$element, FormStateInterface $form_state, array $context) : void {
  // We require a form entity to know how we're being displayed.
  if (!isset($element['entity'])) {
    return;
  }

  switch ($element['entity']['#form_mode']) {
    // Remove "Profiles" when embedding profile fields on the user register
    // form.
    case 'register':
      unset($element['#field_title']);
      break;

    // Add a useful title and explainer text to our visibility settings.
    case 'visibility':
      $element['#type'] = 'fieldset';
      $element['#field_title'] = new TranslatableMarkup("Visibility Settings");
      $element['#description'] = new TranslatableMarkup("Below you can configure the visibility of your profile fields. Visibility for some fields may be enforced on a site-wide level in which case they will not show up here.");
      $element['#after_build'][] = 'social_profile_display_visibility_fields_horizontal';
      break;
  }
}

/**
 * Make the visibility fields show horizontally.
 *
 * This is called as after-build hook for the profile.profile.visibility form
 * mode shown on the user settings page.
 *
 * @param array $element
 *   The profiles visibility sub-form element.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 *
 * @return array
 *   The modified form element.
 *
 * @see social_profile_user_form_profiles_field_alter()
 */
function social_profile_display_visibility_fields_horizontal(array $element, FormStateInterface $form_state) {
  foreach ($element['entity'] as $field_name => &$field) {
    // We're only interested in visibility fields.
    if (strpos($field_name, "vis_") !== 0 && strpos($field_name, "visibility_") !== 0) {
      continue;
    }

    $field['#attributes']['class'][] = "form-horizontal";
  }

  return $element;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function social_profile_form_profile_profile_add_form_alter(array &$form, FormStateInterface $form_state, $form_id) {
  $user = \Drupal::currentUser();
  $profile_settings = \Drupal::config('social_profile.settings');

  // Check for permission on custom edit profile tags, it's only for CM+ who can
  // actually edit a users profile and add profile tags there.
  $form['field_profile_profile_tag']['#access'] = FALSE;
  if (
    $profile_settings->get('allow_tagging_for_lu') ||
    $user->hasPermission('edit profile tags')
  ) {
    $form['field_profile_profile_tag']['#access'] = TRUE;
  }

  // Remove the save and set default submit button on profile creation.
  if (isset($form['actions']['set_default'])) {
    unset($form['actions']['set_default']);
  }

  if (isset($form['field_profile_expertise']['widget']['target_id'])) {
    $form['field_profile_expertise']['widget']['target_id']['#selection_settings']['hide_id'] = TRUE;
  }

  if (isset($form['field_profile_interests']['widget']['target_id'])) {
    $form['field_profile_interests']['widget']['target_id']['#selection_settings']['hide_id'] = TRUE;
  }

  if (isset($form['field_profile_nationality']['widget']['target_id'])) {
    $form['field_profile_nationality']['widget']['target_id']['#selection_settings']['hide_id'] = TRUE;
  }

  // Add custom submit handler just for redirect purposes. We don't want to
  // override the form::save in profile.
  $form['actions']['submit']['#submit'][] = '_social_profile_profile_edit_form_submit';
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function social_profile_form_profile_profile_edit_form_alter(array &$form, FormStateInterface $form_state, $form_id) {
  $viewing_user = \Drupal::currentUser();
  $profile_settings = \Drupal::config('social_profile.settings');

  /** @var \Drupal\profile\Entity\Profile $profile */
  $profile = $form_state->getFormObject()->getEntity();

  // Check for permission on custom edit profile tags, it's only for CM+ who can
  // actually edit a users profile and add profile tags there.
  $form['field_profile_profile_tag']['#access'] = FALSE;
  if (
    $profile_settings->get('allow_tagging_for_lu') ||
    $viewing_user->hasPermission('edit profile tags')
  ) {
    $form['field_profile_profile_tag']['#access'] = TRUE;
  }

  // Remove the save and set default submit button on profile edit.
  if (isset($form['actions']['set_default'])) {
    unset($form['actions']['set_default']);
  }

  if (isset($form['field_profile_expertise']['widget']['target_id'])) {
    $form['field_profile_expertise']['widget']['target_id']['#selection_settings']['hide_id'] = TRUE;
  }

  if (isset($form['field_profile_interests']['widget']['target_id'])) {
    $form['field_profile_interests']['widget']['target_id']['#selection_settings']['hide_id'] = TRUE;
  }

  if (isset($form['field_profile_nationality']['widget']['target_id'])) {
    $form['field_profile_nationality']['widget']['target_id']['#selection_settings']['hide_id'] = TRUE;
  }

  // Check if the Social Profile Fields module is on.
  // @todo Update this for social_profile_fields merge.
  if (\Drupal::moduleHandler()->moduleExists('social_profile_fields')) {
    // Load the profile fields and check if at least one of them can be changed.
    // Load the profile fields and check if at least one of them can be changed.
    $profile_fields = \Drupal::entityTypeManager()
      ->getStorage('field_config')
      ->loadByProperties([
        'entity_type' => 'profile',
        'bundle' => 'profile',
      ]);

    if ($profile_fields) {
      $empty_profile = TRUE;

      foreach ($profile_fields as $field) {
        if (isset($form[$field->get('field_name')]) && $form[$field->get('field_name')]['#access'] === TRUE) {
          $empty_profile = FALSE;
        }
      }

      // There are no fields the user can edit here. Set an explanatory message
      // and disable the Save button.
      if ($empty_profile === TRUE) {
        $form['empty_profile'] = [
          '#type' => 'fieldset',
        ];
        // If a user is viewing their own profile, suggest they change settings.
        if ($viewing_user->id() === $profile->getOwnerId()) {
          $settings_link = Link::createFromRoute(
            t('account settings here'),
            'entity.user.edit_form',
            ['user' => $profile->getOwnerId()]
          )->toString();
          $form['empty_profile']['notice'] = [
            '#type' => 'html_tag',
            '#tag' => 'p',
            '#value' => t(
              'There is no profile information you can change here. Change your @settings.',
              ['@settings' => $settings_link]
            ),
          ];
        }
        // For other users there's nothing left to do.
        else {
          $form['empty_profile']['notice'] = [
            '#type' => 'html_tag',
            '#tag' => 'p',
            '#value' => t('There is no profile information you can change here.'),
          ];
        }

        $form['actions']['submit']['#disabled'] = TRUE;
      }
    }
  }

  // Add custom submit handler just for redirect purposes. We don't want to
  // override the form::save in profile.
  $form['actions']['submit']['#submit'][] = '_social_profile_profile_edit_form_submit';

  // Add cancel button, so user can easily navigate form edit form to profile.
  $form['actions']['cancel'] = [
    '#type' => 'link',
    '#title' => t('Cancel'),
    '#url' => Url::fromRoute('social_profile.view_user_profile', ['user' => $profile->getOwnerId()]),
  ];
}

/**
 * Form submit for profile_profile_edit_form and profile_profile_add_form.
 *
 * @param array $form
 *   The profile edit form.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state interface.
 */
function _social_profile_profile_edit_form_submit(array $form, FormStateInterface $form_state) {
  /** @var \Drupal\profile\Entity\Profile $profile */
  $profile = $form_state->getFormObject()->getEntity();

  // Let's be on the safe side.
  if ($profile instanceof Profile) {
    // Get the uid of the profile.
    $uid = $profile->getOwnerId();
    // Invalidate cache tag.
    Cache::invalidateTags(['user:breadcrumb:' . $uid]);
    // Set redirect to the profile page when a user saves their profile.
    $form_state->setRedirect(
      'social_profile.view_user_profile', [
        'user' => $uid,
      ]
    );
  }
}

/**
 * Implements hook_local_tasks_alter().
 */
function social_profile_local_tasks_alter(&$local_tasks) {
  // Remove the profile main "Profile information" from the local tabs.
  if (!empty($local_tasks['entity.profile.user_profile_form:profile.type.main'])) {
    unset($local_tasks['entity.profile.user_profile_form:profile.type.main']);
  }
  if (!empty($local_tasks['entity.profile.user_profile_form:profile.type.profile'])) {
    unset($local_tasks['entity.profile.user_profile_form:profile.type.profile']);
  }
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function social_profile_menu_local_tasks_alter(&$data, $route_name) {
  if (isset($data['tabs'][0]['profile.user_page:profile'])) {
    unset($data['tabs'][0]['profile.user_page:profile']);
  }
}

/**
 * Implements hook_preprocess_fieldset().
 */
function social_profile_preprocess_fieldset(&$variables) {
  // Style our checkboxes as nested checkboxes.
  if (isset($variables['element']['#name']) && $variables['element']['#name'] === 'profile_tag') {
    $variables['attributes']['class'][] = 'checkboxes--nested';
  }
}

/**
 * Implements hook_preprocess_input().
 */
function social_profile_preprocess_input(&$variables) {
  // Edit the profile tag displays to show the hierarchy to users.
  // Only do this if it starts with a - to indicate it's a child.
  if (
    !empty($variables['element']['#parents'])
    && $variables['element']['#parents'][0] === 'profile_tag'
    && substr($variables['element']['#title'], 0, 1) === '-'
  ) {
    $variables['element']['#attributes']['class'][] = 'checkboxes--nested__child';
  }
}

/**
 * Implements hook_preprocess_form_element_label().
 */
function social_profile_preprocess_form_element_label(&$variables) {
  // Edit the profile tag displays to show the hierarchy to users.
  // Only do this if it starts with a - to indicate it's a child.
  if (
    isset($variables['element']['#id'])
    && substr($variables['element']['#id'], 0, 17) === 'edit-profile-tag-'
    && substr($variables['element']['#title'], 0, 1) === '-'
  ) {
    $variables['title']['#markup'] = substr($variables['title']['#markup'], 1);
  }
}

/**
 * Implements hook_theme().
 */
function social_profile_theme(): array {
  return [
    'profile__profile__name' => [
      'template' => 'profile--profile--name',
      'render element' => 'elements',
      'base hook' => 'profile',
    ],
  ];
}

/**
 * Implements hook_preprocess_HOOK().
 *
 * Allows modifying link attributes by modules instead of using hardcoded
 * attributes in the theme template.
 */
function social_profile_preprocess_field__field_profile_image(array &$variables): void {
  if ($variables['element']['#view_mode'] === 'compact') {
    $element = &$variables['items'][0]['content'];
    $url = $element['#url'];

    /** @var \Drupal\profile\Entity\ProfileInterface $profile */
    $profile = $variables['element']['#object'];

    $name = $profile->getOwner()->getDisplayName();

    if ($url instanceof Url) {
      $url->mergeOptions([
        'attributes' => ['title' => $name],
      ]);
    }

    $element['#item_attributes']['alt'] = $name;
  }
}

/**
 * Prepares variables for profile templates.
 *
 * Default template: profile.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - elements: An array of elements to display in view mode.
 *   - profile: The profile object.
 *   - view_mode: View mode; e.g., 'full', 'teaser', etc.
 */
function social_profile_preprocess_profile(array &$variables) {
  /** @var \Drupal\profile\Entity\Profile $profile */
  $profile = $variables['profile'];
  $user = $profile->getOwner();
  $current_user = \Drupal::currentUser();

  // See social_user_user_format_name_alter(), DisplayName is either first name
  // + last name, or username if both first and last name aren't filled out.
  $variables['profile_name'] = $user->getDisplayName();
  $variables['profile_contact_url'] = _social_profile_get_contact_url($user);
  $variables['profile_stream_url'] = Url::fromUserInput('/user/' . $profile->getOwnerId() . '/stream');
  $variables['profile_home'] = Url::fromRoute('entity.user.canonical', ['user' => $user->id()]);

  // Set a condition for the label to show in the teaser
  // The actual label text should be changeable in the template.
  // Disable for the LU's own profile.
  $variables['profile_contact_label'] = 'profile_info';
  if (
    \Drupal::moduleHandler()->moduleExists('social_private_message') &&
    $current_user->id() !== $user->id() &&
    $current_user->hasPermission('use private messaging system') &&
    $user->hasPermission('use private messaging system')
  ) {
    $variables['profile_contact_label'] = 'private_message';
    $variables['#cache']['contexts'][] = 'user';
  }

  // Edit profile URL.
  // Get the current route name to check if the user is on the edit or delete
  // page.
  $route = \Drupal::routeMatch()->getRouteName();
  if ($route !== 'profile.user_page.single' && $profile->access('update', $current_user)) {
    $variables['profile_edit_url'] = Url::fromUserInput('/user/' . $profile->getOwnerId() . '/profile');
    $variables['#cache']['contexts'][] = 'route.name';
  }

  // Add the hero styled image if we have access to it.
  if (!empty($profile->field_profile_banner_image->entity) && $profile->field_profile_banner_image->access('view')) {
    $variables['profile_hero_styled_image_url'] = ImageStyle::load('social_xx_large')
      ->buildUrl($profile->field_profile_banner_image->entity->getFileUri());
  }

  // Profile information URL.
  $variables['profile_info_url'] = Url::fromRoute('social_profile.view_user_profile', ['user' => $profile->getOwnerId()]);

  // Prepare variables for statistic block.
  if ($variables['elements']['#view_mode'] === 'statistic') {
    /** @var \Drupal\social_profile\UserStatistics $user_statistics */
    $user_statistics = \Drupal::service('social_profile.user_statistics');
    $variables['profile_topics'] = $user_statistics->nodeCount($user->id(), 'topic');
    $variables['profile_events'] = $user_statistics->nodeCount($user->id(), 'event');
    $variables['profile_groups'] = \Drupal::service('social_group.helper_service')
      ->countGroupMembershipsForUser($user->id());
  }

  /** @var \Drupal\social_profile\SocialProfileTagServiceInterface $tag_service */
  $tag_service = \Drupal::service('social_profile.tag_service');
  $variables['profile_tagging_active'] = $tag_service->isActive();
  $variables['profile_tagging_allow_split'] = $tag_service->allowSplit();

  if (!$profile->get('field_profile_profile_tag')->isEmpty()) {
    $tags = $profile->get('field_profile_profile_tag')->getValue();
    $variables['profile_tagging_hierarchy'] = $tag_service->buildHierarchy($tags);
  }
}

/**
 * Helps determine if current user has access to view the property of user.
 *
 * @param \Drupal\profile\Entity\Profile $profile
 *   The profile the current user is viewing.
 * @param \Drupal\Core\Session\AccountProxyInterface $current_user
 *   The current user.
 * @param string $property
 *   The property against we need to check the access.
 *
 * @return bool
 *   Return TRUE if current user is allowed to see the property else FALSE.
 */
function _social_profile_check_property_access(Profile $profile, AccountProxyInterface $current_user, string $property) {
  // phpcs:ignore
  @trigger_error("_social_profile_check_property_access is deprecated and will be removed in 11.0.0. Use a field access check for the `view` operation instead.", E_USER_DEPRECATED);

  switch ($property) {
    case 'email':
      return $profile->get('field_profile_email')->access('view', $current_user);

    case 'language':
      return $profile->get('field_profile_preferred_language')->access('view', $current_user);
  }

  return FALSE;
}

/**
 * Implements hook_entity_field_access().
 *
 * @todo Remove user access checks and move to field_profile duplicates.
 * @todo Take visibility_ field into account.
 */
function social_profile_entity_field_access(string $operation, FieldDefinitionInterface $field_definition, AccountInterface $account, FieldItemListInterface $items = NULL) : AccessResultInterface {
  $entity_type = $field_definition->getTargetEntityTypeId();
  $entity_bundle = $field_definition->getTargetBundle();
  $field_name = $field_definition->getName();
  /** @var \Drupal\social_profile\FieldManager $field_manager */
  $field_manager = \Drupal::service('social_profile.field_manager');

  // Allow bypassing complex checks if a profile is being viewed by a user with
  // access bypass permissions.
  if ($entity_type === 'profile' && $operation === 'view') {
    $result = AccessResult::allowedIfHasPermission($account, "view any profile fields")
      ->orIf(AccessResult::allowedIfHasPermission($account, "view any ${entity_bundle} profile fields"));

    if ($result->isAllowed()) {
      return $result;
    }
  }

  // We only apply our visibility field based access management to fields that
  // we manage.
  if ($entity_type === 'profile' && $operation === 'view' && $field_manager::isManagedValueField($field_definition)) {
    /** @var string $visibility_stored_by */
    $visibility_stored_by = $field_manager::getVisibilityFieldName($field_definition);

    // If there's no item we're actually checking for then we use the default
    // value.
    if ($items === NULL) {
      // To check the default value we just create a new profile entity.
      /** @var \Drupal\profile\Entity\ProfileInterface $profile */
      $profile = Profile::create(['type' => $entity_bundle]);
    }
    // Otherwise we get the profile the item belongs to and use it if the
    // owner of the profile is allowed to alter visibility.
    else {
      /** @var \Drupal\profile\Entity\ProfileInterface $profile */
      $profile = $items->getEntity();
      $profile_user = $profile->getOwner();

      // If the user can't change the visibility then we also check against a
      // dummy profile so that we use the default value set by a site manager.
      // This ensures that if a site manager re-enables user configurability
      // that the value the user had previously set is respected again.
      if (!$profile_user->hasPermission("edit own ${visibility_stored_by} ${entity_bundle} ${entity_type} field")) {
        /** @var \Drupal\profile\Entity\ProfileInterface $profile */
        $profile = Profile::create(['type' => $entity_bundle]);
      }
    }

    if (!$profile->hasField($visibility_stored_by)) {
      return AccessResult::neutral("Visibility for {$field_definition->getName()} is stored in {visibility_stored_by} but that field does not exist.");
    }

    $field_visibility = $profile->get($visibility_stored_by)->value;
    switch ($field_visibility) {
      case SOCIAL_PROFILE_FIELD_VISIBILITY_PUBLIC:
        return AccessResult::allowed();

      case SOCIAL_PROFILE_FIELD_VISIBILITY_COMMUNITY:
        return AccessResult::allowedIfHasPermission($account, "view " . SOCIAL_PROFILE_FIELD_VISIBILITY_COMMUNITY . " ${entity_bundle} ${entity_type} fields")
          ->orIf(AccessResult::allowedIfHasPermission($account, "view " . SOCIAL_PROFILE_FIELD_VISIBILITY_COMMUNITY . " profile fields"));

      case SOCIAL_PROFILE_FIELD_VISIBILITY_FRIENDS:
        return AccessResult::forbidden("Friends visibility access checks are not yet implemented. This is an illegal visibility field value.");

      case SOCIAL_PROFILE_FIELD_VISIBILITY_PRIVATE:
        return AccessResult::allowedIfHasPermission($account, "view " . SOCIAL_PROFILE_FIELD_VISIBILITY_PRIVATE . " ${field_name} ${entity_bundle} ${entity_type} fields");

      default:
        return AccessResult::neutral("Unknown visibility field value '${field_visibility}'.");
    }

  }
  elseif ($entity_type === "profile" && $operation === 'edit') {
    // If a user doesn't have express permission to edit a field then we must
    // forbid it.
    $permissions = [
      "edit any ${field_name} ${entity_bundle} ${entity_type} field",
    ];

    // If there is an item we can check if it belongs to the user.
    if ($items !== NULL) {
      /** @var \Drupal\profile\Entity\ProfileInterface $profile */
      $profile = $items->getEntity();
      $profile_user = $profile->getOwner();

      if ($profile_user->id() === $account->id()) {
        $permissions[] = "edit own ${field_name} ${entity_bundle} ${entity_type} field";
      }
    }

    $result = AccessResult::allowedIfHasPermissions($account, $permissions, "OR");

    // If a profile entity was checked we must add it as a dependency for the
    // permission checks because viewing a different profile requires different
    // checks.
    if (isset($profile)) {
      $result->addCacheableDependency($profile);
    }

    // Fields are allowed by default, but unless the user has express permission
    // to change these fields we want to deny. We do it this way to keep the
    // cacheability metadata and the reason from the permission check.
    if ($result->isNeutral()) {
      $result = $result->andIf(AccessResult::forbidden());
    }

    return $result;
  }

  return AccessResult::neutral();
}

/**
 * Get the contact URL. This can be private message or other means of contact.
 *
 * @param \Drupal\user\UserInterface $account
 *   The user object.
 *
 * @return \Drupal\Core\Url
 *   The URL to contact the user.
 */
function _social_profile_get_contact_url(UserInterface $account) {
  if (\Drupal::moduleHandler()->moduleExists('social_private_message')) {
    $current_user = \Drupal::currentUser();
    if ($current_user->hasPermission('use private messaging system') && $account->hasPermission('use private messaging system') && $current_user->id() != $account->id()) {
      $members = [$current_user, $account];
      $thread_id = \Drupal::service('private_message.mapper')
        ->getThreadIdForMembers($members);
      if ($thread_id) {
        $url = Url::fromRoute('entity.private_message_thread.canonical', ['private_message_thread' => $thread_id], ['attributes' => ['class' => ['private_message_link']]]);
        if ($url->access($current_user)) {
          return $url;
        }
      }
      return Url::fromRoute('private_message.private_message_create', [], ['query' => ['recipient' => $account->id()]]);
    }
  }
  return Url::fromUserInput('/user/' . $account->id() . '/information');
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 *
 * In order to save a new default profile on user creation.
 */
function social_profile_user_insert(UserInterface $account) {
  // If the new account has a UID, we can create a default profile.
  // Default image is added through the field settings.
  if (!empty($account->id())) {
    /** @var \Drupal\profile\Entity\ProfileTypeInterface $profile_type */
    $profile_type = ProfileType::load('profile');
    // Sometimes profile fields are already requested during registration.
    // In those cases, the profile will already be created from that.
    if ($profile_type !== NULL && $profile_type->getRegistration() === FALSE) {
      $default_values = [
        'type' => $profile_type->id(),
        'uid' => $account->id(),
      ];

      // Get all field instances for the profile entity and check if the address
      // field exists.
      $instances = \Drupal::service('entity_field.manager')
        ->getFieldDefinitions('profile', $profile_type->id());
      if (array_key_exists('field_profile_address', $instances)) {
        // Set the users default country to the site default country.
        $default_values['field_profile_address'][0]['country_code'] = \Drupal::config('system.date')
          ->get('country.default');
      }

      // Create a profile.
      $profile = Profile::create($default_values);
      $profile->save();
    }
    else {
      /** @var \Drupal\profile\ProfileStorageInterface $profile_storage */
      $profile_storage = \Drupal::entityTypeManager()->getStorage('profile');
      $profile = $profile_storage->loadByUser($account, 'profile');
      assert($profile !== NULL, "Profile type 'profile' was configured to be created during registration but no profile existed for the user ({$account->id()}).");
    }

    social_profile_sync_user_fields_to_profile($account, $profile);
  }
}

/**
 * Implements hook_ENTITY_TYPE_update().
 */
function social_profile_user_update(UserInterface $user) : void {
  /** @var \Drupal\profile\ProfileStorageInterface $profile_storage */
  $profile_storage = \Drupal::entityTypeManager()->getStorage('profile');
  $profile = $profile_storage->loadByUser($user, 'profile');
  assert($profile !== NULL, "User updated without a profile, this means the user insert logic that should automatically create a profile is broken.");
  social_profile_sync_user_fields_to_profile($user, $profile);
}

/**
 * Synchronise shared fields from the user entity to the profile.
 *
 * Some data for users such as email and langcode should be displayed on the
 * users profile depending on user configuration. Managing all this display data
 * in a single entity is easier for access and display but the data is owned by
 * the user entity, so rather than edit it directly this function synchronises
 * it from the user entity to the profile.
 *
 * @param \Drupal\user\UserInterface $user
 *   The user to synchronise data for.
 * @param \Drupal\profile\Entity\ProfileInterface $profile
 *   The profile entity to synchronise data to.
 */
function social_profile_sync_user_fields_to_profile(UserInterface $user, ProfileInterface $profile) : void {
  $profile
    ->set('field_profile_email', $user->getEmail())
    ->set('field_profile_preferred_language', $user->getPreferredLangcode())
    ->save();
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function social_profile_form_user_form_alter(&$form, FormStateInterface $form_state) {
  $form['#pre_render'][] = [SocialProfileUserFormAlter::class, 'preRender'];
}

/**
 * Gets the users profile by route.
 *
 * @return mixed
 *   The profile or NULL if nothing could be found.
 */
function _social_profile_get_profile_from_route() {
  $profile = NULL;
  $entity_type_manager = \Drupal::entityTypeManager();

  $account = \Drupal::routeMatch()->getParameter('user');
  if (!is_object($account) && !is_null($account)) {
    $account = $entity_type_manager
      ->getStorage('user')
      ->load($account);
  }

  if (!empty($account)) {
    $storage = $entity_type_manager->getStorage('profile');
    $profile = $storage->loadByUser($account, 'profile');
  }

  return $profile;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function social_profile_form_user_register_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Set User Register form Email field as required.
  $form['account']['mail']['#required'] = TRUE;

  // Move the profile fields form into the account block.
  if (isset($form['profile_profiles'])) {
    $form['account']['profile_profiles'] = $form['profile_profiles'];
    unset($form['profile_profiles']);
  }
}

/**
 * Implements hook_ENTITY_TYPE_view_alter().
 */
function social_profile_profile_view_alter(array &$build, EntityInterface $entity, EntityViewDisplayInterface $display) {
  $image_item = $build['field_profile_image'][0]['#item'] ?? NULL;

  // Image doesn't exists.
  if (!($image_item instanceof FieldItemInterface)) {
    return;
  }

  /** @var \Drupal\Core\Session\AccountProxy $current_user */
  $current_user = \Drupal::currentUser();

  // If the current user is anonymous, it means it does not have access to the
  // users profile.
  if ($current_user->isAnonymous() &&
    isset($display->get('content')['field_profile_image'])
  ) {

    // Try to load the profile picture.
    $image = $entity->get('field_profile_image')->entity;

    // Must have a value and not be NULL.
    if ($image instanceof FileInterface) {
      // Potentially the file is in the private file system. In that case,
      // anonymous user don't have access to it.
      $file_scheme = \Drupal::service('stream_wrapper_manager')->getScheme($image->getFileUri());
      if ($file_scheme === 'private') {
        // Load default data.
        $replacement_data = social_profile_get_default_image();
        // Time to override the data that going to be rendered.
        $image_item->set('target_id', $replacement_data['id']);
        $image_item->set('width', $replacement_data['width']);
        $image_item->set('height', $replacement_data['height']);
        // Put replacement data back in the object that's about to be built.
        $build['field_profile_image'][0]['#item'] = $image_item;
      }
    }
  }
}

/**
 * Function to fetch the default profile image.
 */
function social_profile_get_default_image() {
  // Load default image.
  $config_factory = \Drupal::configFactory();
  $field_image_config = $config_factory->getEditable('field.field.profile.profile.field_profile_image');
  $default_image = $field_image_config->get('settings.default_image');
  // Load by uuid.
  $files = \Drupal::entityTypeManager()
    ->getStorage('file')
    ->loadByProperties(['uuid' => $default_image['uuid']]);
  // Pop it.
  $file = array_pop($files);
  // Set in an array.
  $data = [
    "id" => $file->id(),
    "width" => $default_image['width'],
    "height" => $default_image['height'],
  ];
  // Retun the array.
  return $data;
}

/**
 * Implements hook_social_user_name_display_suggestions().
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
 */
function social_profile_social_user_name_display_suggestions(AccountInterface $account): array {
  $suggestions = [];

  $entityTypeManager = \Drupal::entityTypeManager();

  /** @var \Drupal\profile\ProfileStorageInterface $storage */
  $storage = $entityTypeManager->getStorage('profile');

  if ($user_profile = $storage->loadByUser($account, 'profile')) {
    /** @var \Drupal\profile\ProfileAccessControlHandler $accessControlHandler */
    $accessControlHandler = $entityTypeManager->getAccessControlHandler('profile');

    $first_name_field = $user_profile->get('field_profile_first_name');
    $last_name_field = $user_profile->get('field_profile_last_name');

    $first_name = $accessControlHandler->fieldAccess('view', $first_name_field->getFieldDefinition(), NULL, $first_name_field, FALSE)
      ? $first_name_field->getString()
      : "";
    $last_name = $accessControlHandler->fieldAccess('view', $last_name_field->getFieldDefinition(), NULL, $last_name_field, FALSE)
      ? $last_name_field->getString()
      : "";

    $account_name = trim($first_name . " " . $last_name);
    if ($account_name !== '') {
      // Add the full name with a default weight.
      $suggestions['full_name'] = [
        'name' => $account_name,
      ];
    }
  }

  return $suggestions;
}

/**
 * Hide timezone fields group label.
 */
function _social_profile_form_pre_render($element) {
  $element['group_locale_settings']['timezone']['#title'] = NULL;
  return $element;
}

/**
 * Implements hook_entity_operation_alter().
 */
function social_profile_entity_operation_alter(array &$operations, EntityInterface $entity) {
  if ($entity->getEntityTypeId() === 'user') {
    if (isset($operations['edit'])) {
      $operations['edit']['title'] = t('Edit account');
      $operations['edit_profile'] = [
        'title' => t('Edit profile'),
        'weight' => (isset($operations['edit']['weight'])) ? $operations['edit']['weight']-- : 0,
        'url' => Url::fromUserInput('/user/' . $entity->id() . '/profile'),
      ];
    }
  }
}

/**
 * Implements hook_social_user_account_header_account_links().
 *
 * Adds the "View my profile" and "Edit profile" link to the user menu.
 */
function social_profile_social_user_account_header_account_links(array $context) {
  // We require a user for these links.
  if (empty($context['user']) || !($context['user'] instanceof AccountInterface)) {
    return [];
  }

  return [
    'my_profile' => [
      '#type' => 'link',
      '#attributes' => [
        'title' => new TranslatableMarkup('View my profile'),
      ],
      '#title' => new TranslatableMarkup('My profile'),
      '#weight' => 500,
    ] + Url::fromRoute('user.page')->toRenderArray(),
    'edit_profile' => [
      '#type' => 'link',
      '#attributes' => [
        'title' => new TranslatableMarkup("Edit profile"),
      ],
      '#title' => new TranslatableMarkup("Edit profile"),
      '#weight' => 1300,
    ] + Url::fromRoute('profile.user_page.single', [
      'user' => $context['user']->id(),
      'profile_type' => 'profile',
    ])->toRenderArray(),
  ];
}

/**
 * Implements hook_social_user_account_header_items_alter().
 *
 * Replaces the default user icon with the user's profile image if available.
 */
function social_profile_social_user_account_header_items_alter(array &$menu_items, array $context) {
  // If we don't have an account_box there's nothing to do.
  if (empty($menu_items['account_box'])) {
    return;
  }

  // A user is required to find the profile image.
  if (empty($context['user']) || !($context['user'] instanceof AccountInterface)) {
    return;
  }

  $storage = \Drupal::entityTypeManager()->getStorage('profile');
  $profile = $storage->loadByUser($context['user'], 'profile');

  // If the user does not have a profile then there's no profile image.
  if (empty($profile)) {
    return;
  }

  // Provide a render array as image which will overrule the user icon.
  $menu_items['account_box']['#image'] = \Drupal::entityTypeManager()
    ->getViewBuilder('profile')
    ->view($profile, 'small');

}

/**
 * Implements hook_ENTITY_TYPE_access().
 */
function social_profile_profile_access(EntityInterface $entity, $operation, AccountInterface $account) {

  $display_profile_teaser = FALSE;
  $route_match = \Drupal::service('current_route_match');
  $allowed_node_types = [
    'landing_page',
    'dashboard',
  ];

  if ($route_match->getRouteName() === 'entity.node.canonical') {
    $node = $route_match->getParameter('node');

    if (!is_null($node) && !$node instanceof Node) {
      $node = Node::load($node);
    }
    if ($node instanceof Node && in_array($node->getType(), $allowed_node_types)) {
      $display_profile_teaser = TRUE;
    }
  }

  // Provides access only to viewing user profile info, like referenced data in
  // featured items for landing & dashboard pages, if the current user has no
  // permissions.
  if (
    $operation === 'view' &&
    $display_profile_teaser &&
    !$account->hasPermission('view any profile profile')
  ) {
    return AccessResult::allowed();
  }
}

/**
 * Show exposed filters block only when tagging filters are enabled for profile.
 *
 * Implements hook_block_access().
 */
function social_profile_block_access(Block $block, $operation, AccountInterface $account) {
  if ($operation === 'view' && ($block->getPluginId() === 'views_exposed_filter_block:newest_users-page_newest_users')) {
    $access = AccessResult::forbidden();
    if (\Drupal::moduleHandler()->moduleExists('social_tagging')) {
      /** @var \Drupal\social_tagging\SocialTaggingService $tag_service */
      $tag_service = \Drupal::service('social_tagging.tag_service');
      if ($tag_service->profileActive()) {
        $access = AccessResult::allowed();
      }
    }
    return $access;
  }

  // No opinion.
  return AccessResult::neutral();
}

/**
 * Implements hook_entity_form_display_alter().
 */
function social_profile_entity_form_display_alter(EntityFormDisplayInterface $form_display, array $context) {
  if ($form_display->id() === 'profile.profile.default') {
    $content = $form_display->get('content');
    if (isset($content['field_profile_profile_tag'])) {
      $content['field_profile_profile_tag']['type'] = 'social_profile_tag_split';
      $form_display->set('content', $content);
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function social_profile_form_taxonomy_overview_terms_alter(&$form, FormStateInterface $form_state, $form_id) {
  if (\Drupal::service('social_profile.tag_service')->allowSplit()) {
    $storage = $form_state->getStorage();
    /** @var \Drupal\taxonomy\Entity\Vocabulary $vocabulary */
    $vocabulary = $storage['taxonomy']['vocabulary'];

    if ($vocabulary->id() === 'profile_tag') {
      // Remove edit/delete links.
      foreach (Element::children($form['terms']) as $name) {
        unset($form['terms'][$name]['weight']);
      }

      // Hide Save button.
      $form['actions']['submit']['#access'] = FALSE;

      // Remove tableDrag.
      unset($form['terms']['#tabledrag']);

      // Remove Weight column.
      unset($form['terms']['#header'][1]);
    }
  }
}

/**
 * Implements hook_views_plugins_filter_alter().
 */
function social_profile_views_plugins_filter_alter(array &$plugins) {
  $plugins['search_api_term']['class'] = SocialSearchApiSplitProfileTerms::class;
}

/**
 * Implements hook_social_core_default_main_menu_links_alter().
 */
function social_profile_social_core_default_main_menu_links_alter(array &$links) {
  $link = \Drupal::entityTypeManager()->getStorage('menu_link_content')
    ->loadByProperties([
      'title' => 'All members',
      'menu_name' => 'main',
      'link' => 'internal:/all-members',
    ]);
  $link = end($link);

  // Ensure that the end() doesn't return FALSE, and we have link instance.
  if ($link instanceof MenuLinkContentInterface) {
    $links[] = $link;
  }
}

/**
 * Implements hook_social_tagging_type().
 */
function social_profile_social_tagging_type(): string {
  return 'profile';
}
