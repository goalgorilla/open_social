<?php

/**
 * @file
 * The Social profile module.
 */

use Drupal\Core\Access\AccessResult;
use Drupal\Core\Access\AccessResultInterface;
use Drupal\Core\Cache\Cache;
use Drupal\Core\Entity\Display\EntityFormDisplayInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Field\FieldItemInterface;
use Drupal\Core\Field\FieldDefinitionInterface;
use Drupal\Core\Field\FieldConfigInterface;
use Drupal\Core\Field\FieldItemListInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Installer\InstallerKernel;
use Drupal\Core\Link;
use Drupal\Core\Render\Element;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\StringTranslation\TranslatableMarkup;
use Drupal\Core\Url;
use Drupal\file\FileInterface;
use Drupal\field\Entity\FieldConfig;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\field\FieldStorageConfigInterface;
use Drupal\image\Entity\ImageStyle;
use Drupal\menu_link_content\MenuLinkContentInterface;
use Drupal\profile\Entity\Profile;
use Drupal\profile\Entity\ProfileInterface;
use Drupal\profile\Entity\ProfileType;
use Drupal\profile\ProfileStorageInterface;
use Drupal\social_profile\FieldManager;
use Drupal\social_profile\Plugin\views\filter\SocialSearchApiSplitProfileTerms;
use Drupal\social_profile\SocialProfileUserFormAlter;
use Drupal\user\Entity\Role;
use Drupal\user\EntityOwnerInterface;
use Drupal\user\UserInterface;

const SOCIAL_PROFILE_SUGGESTIONS_USERNAME = 'username';
const SOCIAL_PROFILE_SUGGESTIONS_FULL_NAME = 'full_name';
const SOCIAL_PROFILE_SUGGESTIONS_ALL = 'all';

const SOCIAL_PROFILE_FIELD_VISIBILITY_PUBLIC = 'public';
const SOCIAL_PROFILE_FIELD_VISIBILITY_COMMUNITY = 'community';
// Open Social does not yet support friends but it's a logical step between
// private and community which is why the constant is already documented here.
const SOCIAL_PROFILE_FIELD_VISIBILITY_FRIENDS = 'friends';
const SOCIAL_PROFILE_FIELD_VISIBILITY_PRIVATE = 'private';

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function social_profile_field_storage_config_insert(FieldStorageConfigInterface $field_storage_config) : void {
  if ($field_storage_config->getTargetEntityTypeId() === "profile" && $field_storage_config->getThirdPartySetting('social_profile', 'visibility_for') === NULL) {
    $visibility_storage_config = social_profile_create_visibility_field_storage_config_for($field_storage_config);

    $field_storage_config->setThirdPartySetting('social_profile', 'visibility_stored_by', $visibility_storage_config->getName());
    $field_storage_config->save();
  }
}

/**
 * Implements hook_ENTITY_TYPE_delete().
 */
function social_profile_field_storage_config_delete(FieldStorageConfigInterface $field_storage_config) : void {
  if ($field_storage_config->getTargetEntityTypeId() === "profile" && $field_storage_config->getThirdPartySetting('social_profile', 'visibility_stored_by') !== NULL) {
    social_profile_delete_visibility_field_storage_config_for($field_storage_config);
  }
}

/**
 * Create visibility field storage configuration for another field.
 *
 * @param \Drupal\field\FieldStorageConfigInterface $field_storage_config
 *   The field storage configuration for which to create the visibility field
 *   storage configuration.
 *
 * @return \Drupal\field\FieldStorageConfigInterface
 *   The created field storage config interface.
 */
function social_profile_create_visibility_field_storage_config_for(FieldStorageConfigInterface $field_storage_config) : FieldStorageConfigInterface {
  if ($field_storage_config->getThirdPartySetting('social_profile', 'visibility_for') !== NULL) {
    throw new RuntimeException("Can not create a visibility field storage config for another visibility field storage config, this could create loops.");
  }

  if ($field_storage_config->getThirdPartySetting('social_profile', 'visibility_stored_by') !== NULL) {
    // In case we're adding fields during module install we ignore fields that
    // ship with their storage. This allows visibility field config to be safely
    // exported and imported.
    if (\Drupal::isConfigSyncing() || InstallerKernel::installationAttempted() || \Drupal::getContainer()->getParameter('kernel.environment') === "testing") {
      $visibility_storage_config = FieldStorageConfig::loadByName(
        $field_storage_config->getTargetEntityTypeId(),
        $field_storage_config->getThirdPartySetting('social_profile', 'visibility_stored_by')
      );

      if ($visibility_storage_config === NULL) {
        throw new RuntimeException("A field indicated it already had visibility field but the field itself seems to have been deleted.");
      }

      return $visibility_storage_config;
    }

    // In other cases we don't expect fields to already have this setting so
    // this probably indicates a programmer caused error.
    throw new RuntimeException("Tried to create a visibility field storage config for a field that already has a visibility field storage config.");
  }

  /** @var \Drupal\field\FieldStorageConfigInterface $visibility_storage_config */
  $visibility_storage_config = FieldStorageConfig::create([
    'field_name' => social_profile_get_visibility_field_name($field_storage_config->getName()),
    'entity_type' => $field_storage_config->getTargetEntityTypeId(),
    'type' => 'list_string',
    'module' => 'social_profile',
    'cardinality' => 1,
    'translatable' => FALSE,
    'locked' => TRUE,
    'settings' => [
      'allowed_values_function' => 'social_profile_field_visibility_values',
    ],
  ]);
  $visibility_storage_config->setThirdPartySetting('social_profile', 'visibility_for', $field_storage_config->getName());
  $visibility_storage_config->save();

  return $visibility_storage_config;
}

/**
 * Delete visibility field storage configuration for another field.
 *
 * @param \Drupal\field\FieldStorageConfigInterface $field_storage_config
 *   The field storage configuration for which to delete the corresponding
 *   visibility field storage configuration.
 */
function social_profile_delete_visibility_field_storage_config_for(FieldStorageConfigInterface $field_storage_config) : void {
  if ($field_storage_config->getThirdPartySetting('social_profile', 'visibility_stored_by') === NULL) {
    throw new RuntimeException("Can not remove visibility field config storage for field without visibility field config storage.");
  }

  /** @var \Drupal\field\FieldStorageConfigInterface|null $visibility_storage_config */
  $visibility_storage_config = FieldStorageConfig::loadByName($field_storage_config->getTargetEntityTypeId(), $field_storage_config->getThirdPartySetting('social_profile', 'visibility_stored_by'));

  // If we can't load a visibility storage config then we're done.
  if ($visibility_storage_config !== NULL) {
    if ($visibility_storage_config->getThirdPartySetting('social_profile', 'visibility_for') !== $field_storage_config->getName()) {
      throw new RuntimeException("A field storage config indicated that its visibility was stored by a visibility field storage that was not intended for this field.");
    }

    $visibility_storage_config->delete();
  }

  // While slightly awkward for the API we can not save here since that may
  // restore a field storage config entity that is being deleted.
  $field_storage_config->setThirdPartySetting('social_profile', 'visibility_stored_by', NULL);
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function social_profile_field_config_insert(FieldConfigInterface $field_config) : void {
  social_profile_ensure_associated_visibility_field_config($field_config);
  social_profile_ensure_sitemanager_managed_field_permissions($field_config);
}

/**
 * Implements hook_ENTITY_TYPE_delete().
 */
function social_profile_field_config_delete(FieldConfigInterface $field_config) : void {
  social_profile_delete_associated_visibility_field_config($field_config);
}

/**
 * Ensures that a field config entity exists to mirror a profile field.
 *
 * When fields are created this adds the field config for the field storage that
 * is created elsewhere. This ensures an adjustable config entity exists for
 * each bundle where a field is added.
 *
 * @param \Drupal\Core\Field\FieldConfigInterface $field_config
 *   The field config of the field for which a visibility field config should be
 *   created.
 */
function social_profile_ensure_associated_visibility_field_config(FieldConfigInterface $field_config) : void {
  // We only support storage configs from the field module, not those in Drupal
  // core (i.e. entity base fields).
  $field_storage_config = $field_config->getFieldStorageDefinition();
  if (!$field_storage_config instanceof FieldStorageConfigInterface) {
    return;
  }

  // This only works for fieldable fields. Those are required to have a bundle.
  $bundle = $field_config->getTargetBundle();
  if ($bundle === NULL) {
    throw new \InvalidArgumentException("Field config ({$field_config->getName()}) requesting visibility field must be associated with a bundle.");
  }

  // Don't do anything when we're called for a field config that belongs to a
  // field storage that stores visibility information. That field config is
  // probably created by ourselves and would create infinite loops.
  if ($field_storage_config->getThirdPartySetting('social_profile', 'visibility_for') !== NULL) {
    return;
  }

  // Avoid trying to create a field config when there's no visibility storage
  // for the field that we're configuring visibility info for. This can happen
  // if a field has asked to opt-out of visibility configuration.
  $visibility_field_name = $field_storage_config->getThirdPartySetting('social_profile', 'visibility_stored_by');
  if ($visibility_field_name === NULL) {
    return;
  }

  $visibility_storage_config = FieldStorageConfig::loadByName($field_storage_config->getTargetEntityTypeId(), $visibility_field_name);
  if ($visibility_storage_config === NULL) {
    throw new RuntimeException("{$field_storage_config->getName()} indicated visibility storage in {$visibility_field_name} but that field has no storage entity.");
  }

  // Nothing to do if the visibility field config already exists.
  if (FieldConfig::loadByName($field_config->getTargetEntityTypeId(), $bundle, $visibility_storage_config->getName()) !== NULL) {
    return;
  }

  FieldConfig::create([
    'label' => new TranslatableMarkup("@field_name visibility", ['@field_name' => $field_config->label()]),
    'field_name' => $visibility_field_name,
    'entity_type' => $field_config->getTargetEntityTypeId(),
    'bundle' => $bundle,
    'type' => 'list_string',
    'module' => 'social_profile',
    'translatable' => FALSE,
    'locked' => TRUE,
    'required' => TRUE,
    'default_value' => [
      0 => ['value' => SOCIAL_PROFILE_FIELD_VISIBILITY_COMMUNITY],
    ],
    'settings' => [
      'allowed_values_function' => 'social_profile_field_visibility_values',
    ],
  ])->save();
}

/**
 * Remove the visibility field config for our managed field access.
 *
 * @param \Drupal\Core\Field\FieldConfigInterface $field_config
 *   The value field that is being removed for which to remove the matching
 *   visibility field config.
 */
function social_profile_delete_associated_visibility_field_config(FieldConfigInterface $field_config) : void {
  // We only support storage configs from the field module, not those in Drupal
  // core (i.e. entity base fields).
  $field_storage_config = $field_config->getFieldStorageDefinition();
  if (!$field_storage_config instanceof FieldStorageConfigInterface) {
    return;
  }

  // We only support fields for a bundle.
  $bundle = $field_config->getTargetBundle();
  if ($bundle === NULL) {
    throw new \InvalidArgumentException("Field config ({$field_config->getName()}) requesting visibility field must be associated with a bundle.");
  }

  // No need to delete an associated visibility field config if the deleted
  // field doesn't have one.
  $visibility_field_name = $field_storage_config->getThirdPartySetting('social_profile', 'visibility_stored_by');
  if ($visibility_field_name === NULL) {
    return;
  }

  $visibility_storage_config = FieldStorageConfig::loadByName($field_config->getTargetEntityTypeId(), $visibility_field_name);
  if ($visibility_storage_config === NULL) {
    throw new RuntimeException("{$field_storage_config->getName()} indicated visibility storage in {$visibility_field_name} but that storage does not exist.");
  }

  $visibility_config = FieldConfig::loadByName($field_config->getTargetEntityTypeId(), $bundle, $visibility_storage_config->getName());

  // Nothing to delete if it's already gone.
  if ($visibility_config === NULL) {
    return;
  }

  $visibility_config->delete();
}

/**
 * Ensure the permissions are correct for the site manager for managed fields.
 *
 * These are permissions that the site manager themselves can not give or take
 * using the profile settings page. They can control all other permissions.
 *
 * Gives the site manager the view private file permission. Gives the site
 * manager the edit any profile field permission.
 *
 * Only applies to fields that are managed by our visibility system.
 *
 * @param \Drupal\Core\Field\FieldConfigInterface $field_config
 *   The field config to set the permission for.
 */
function social_profile_ensure_sitemanager_managed_field_permissions(FieldConfigInterface $field_config) : void {
  // Ignore fields that opted out of being managed.
  if (!FieldManager::isOptedOutOfFieldAccessManagement($field_config)) {
    return;
  }

  $sitemanager_role = Role::load('sitemanager');

  // This would be a platform configuration error but its safe to ignore here.
  if ($sitemanager_role === NULL) {
    return;
  }

  $field_name = $field_config->getName();

  $sitemanager_role
    ->grantPermission("view " . SOCIAL_PROFILE_FIELD_VISIBILITY_PRIVATE . " ${field_name} {$field_config->getTargetBundle()} {$field_config->getTargetEntityTypeId()} fields")
    ->grantPermission("edit any ${field_name} profile profile field")
    ->save();
}

/**
 * Generate the visibility field name.
 *
 * Field names need to be less than 32 characters but since we're deriving our
 * name from another field name we may already go over that by simply appending
 * another string to the name.
 *
 * @param string $field_name
 *   The name of the field to get the visibility field name for.
 *
 * @return string
 *   The name of the visibility field.
 */
function social_profile_get_visibility_field_name(string $field_name) : string {
  // We prefer just prepending our prefix.
  $visibility_name = 'visibility_' . $field_name;
  // But we must limit based on the FieldStorageConfig rules.
  if (mb_strlen($visibility_name) > FieldStorageConfig::NAME_MAX_LENGTH) {
    // In that case we borrow a trick from
    // \Drupal\Core\Entity\Sql\DefaultTableMapping::generateFieldTableName().
    $field_name_hash = substr(hash('sha256', $field_name), 0, 28);
    $visibility_name = "vis_" . $field_name_hash;
  }

  return $visibility_name;
}

/**
 * Provides the available allowed visibility values.
 *
 * The values available are not meant to be editable. However, using a value
 * function allows Open Social to add new allowed values (such as FRIENDS) in
 * the future without having to provide configuration updates for a lot of
 * fields.
 *
 * If you're thinking of adding a value here, please discuss with the core team
 * first. There may be other ways to achieve what you want.
 *
 * @return array
 *   The values allowed in visibility fields.
 */
function social_profile_field_visibility_values() : array {
  return [
    SOCIAL_PROFILE_FIELD_VISIBILITY_PUBLIC => new TranslatableMarkup("Public"),
    SOCIAL_PROFILE_FIELD_VISIBILITY_COMMUNITY => new TranslatableMarkup("Community"),
    SOCIAL_PROFILE_FIELD_VISIBILITY_PRIVATE => new TranslatableMarkup("Private"),
  ];
}

/**
 * Implements hook_field_widget_form_alter().
 */
function social_profile_field_widget_form_alter(&$element, FormStateInterface $form_state, $context) {
  /** @var \Drupal\Core\Field\FieldDefinitionInterface $field_definition */
  $field_definition = $context['items']->getFieldDefinition();
  switch ($field_definition->getName()) {
    case 'field_profile_phone_number':
      // @todo Remove this when rule for .form-tel elements will be added.
      $element['value']['#attributes']['class'][] = 'form-text';
      $element['value']['#attributes']['autocomplete'][] = 'tel';
      break;

    case 'field_profile_address':
      // @todo Remove this when script for custom selects will be added.
      $element['country_code']['#attributes']['class'][] = 'browser-default';
      break;

    // Alter how profiles are embedded within the user edit for.
    case 'profile_profiles':
      social_profile_user_form_profiles_field_alter($element, $form_state, $context);
      break;
  }

  if (FieldManager::isVisibilityField($field_definition)) {
    // The field is required but we don't want to display this for all fields.
    // The select element itself already enforces that a value is selected.
    $element['#required'] = FALSE;
  }

  // This replaces all user entity references with our EntityReferenceSelection.
  if ($field_definition->getType() === 'entity_reference') {
    if (
      isset($element['target_id']['#target_type']) &&
      $element['target_id']['#target_type'] === 'user' &&
      $element['target_id']['#type'] !== 'social_private_message_entity_autocomplete'
    ) {
      $element['target_id']['#selection_handler'] = 'social';
    }
  }
}

/**
 * Alter how an embedded profile form works in the user edit form.
 *
 * Not called as actual alter hook but called from the social profile widget
 * form alter.
 */
function social_profile_user_form_profiles_field_alter(array &$element, FormStateInterface $form_state, array $context) : void {
  // We require a form entity to know how we're being displayed.
  if (!isset($element['entity'])) {
    return;
  }

  switch ($element['entity']['#form_mode']) {
    // Remove "Profiles" when embedding profile fields on the user register
    // form.
    case 'register':
      $element['#after_build'][] = 'social_profile_hide_profile_title_on_registration_page';
      break;

    // Add a useful title and explainer text to our visibility settings.
    case 'visibility':
      $element['#type'] = 'fieldset';
      $element['#field_title'] = new TranslatableMarkup("Visibility settings");
      $element['#description'] = new TranslatableMarkup("Below you can configure the visibility of your profile fields. Visibility for some fields may be enforced on a site-wide level in which case they will not show up here.");
      $element['#after_build'][] = 'social_profile_display_visibility_fields_horizontal';
      break;
  }
}

/**
 * Hide the profile details title on the registration page.
 */
function social_profile_hide_profile_title_on_registration_page(array $element, FormStateInterface $form_state) : array {
  unset($element['#title']);
  return $element;
}

/**
 * Make the visibility fields show horizontally.
 *
 * This is called as after-build hook for the profile.profile.visibility form
 * mode shown on the user settings page.
 *
 * @param array $element
 *   The profiles visibility sub-form element.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 *
 * @return array
 *   The modified form element.
 *
 * @see social_profile_user_form_profiles_field_alter()
 */
function social_profile_display_visibility_fields_horizontal(array $element, FormStateInterface $form_state) {
  foreach ($element['entity'] as $field_name => &$field) {
    // We're only interested in visibility fields.
    if (strpos($field_name, "vis_") !== 0 && strpos($field_name, "visibility_") !== 0) {
      continue;
    }

    $field['#attributes']['class'][] = "form-horizontal";
  }

  return $element;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function social_profile_form_profile_profile_add_form_alter(array &$form, FormStateInterface $form_state, $form_id) {
  // Remove the save and set default submit button on profile creation.
  if (isset($form['actions']['set_default'])) {
    unset($form['actions']['set_default']);
  }

  if (isset($form['field_profile_expertise']['widget']['target_id'])) {
    $form['field_profile_expertise']['widget']['target_id']['#selection_settings']['hide_id'] = TRUE;
  }

  if (isset($form['field_profile_interests']['widget']['target_id'])) {
    $form['field_profile_interests']['widget']['target_id']['#selection_settings']['hide_id'] = TRUE;
  }

  if (isset($form['field_profile_nationality']['widget']['target_id'])) {
    $form['field_profile_nationality']['widget']['target_id']['#selection_settings']['hide_id'] = TRUE;
  }

  // Add custom submit handler just for redirect purposes. We don't want to
  // override the form::save in profile.
  $form['actions']['submit']['#submit'][] = '_social_profile_profile_edit_form_submit';
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function social_profile_form_profile_profile_edit_form_alter(array &$form, FormStateInterface $form_state, $form_id) {
  $viewing_user = \Drupal::currentUser();
  $profile_settings = \Drupal::config('social_profile.settings');

  /** @var \Drupal\profile\Entity\Profile $profile */
  $profile = $form_state->getFormObject()->getEntity();

  // Remove the save and set default submit button on profile edit.
  if (isset($form['actions']['set_default'])) {
    unset($form['actions']['set_default']);
  }

  if (isset($form['field_profile_expertise']['widget']['target_id'])) {
    $form['field_profile_expertise']['widget']['target_id']['#selection_settings']['hide_id'] = TRUE;
  }

  if (isset($form['field_profile_interests']['widget']['target_id'])) {
    $form['field_profile_interests']['widget']['target_id']['#selection_settings']['hide_id'] = TRUE;
  }

  if (isset($form['field_profile_nationality']['widget']['target_id'])) {
    $form['field_profile_nationality']['widget']['target_id']['#selection_settings']['hide_id'] = TRUE;
  }

  // Check if the Social Profile Fields module is on.
  // @todo Update this for social_profile_fields merge.
  if (\Drupal::moduleHandler()->moduleExists('social_profile_fields')) {
    // Load the profile fields and check if at least one of them can be changed.
    // Load the profile fields and check if at least one of them can be changed.
    $profile_fields = \Drupal::entityTypeManager()
      ->getStorage('field_config')
      ->loadByProperties([
        'entity_type' => 'profile',
        'bundle' => 'profile',
      ]);

    if ($profile_fields) {
      $empty_profile = TRUE;

      foreach ($profile_fields as $field) {
        if (isset($form[$field->get('field_name')]) && $form[$field->get('field_name')]['#access'] === TRUE) {
          $empty_profile = FALSE;
        }
      }

      // There are no fields the user can edit here. Set an explanatory message
      // and disable the Save button.
      if ($empty_profile === TRUE) {
        $form['empty_profile'] = [
          '#type' => 'fieldset',
        ];
        // If a user is viewing their own profile, suggest they change settings.
        if ($viewing_user->id() === $profile->getOwnerId()) {
          $settings_link = Link::createFromRoute(
            t('account settings here'),
            'entity.user.edit_form',
            ['user' => $profile->getOwnerId()]
          )->toString();
          $form['empty_profile']['notice'] = [
            '#type' => 'html_tag',
            '#tag' => 'p',
            '#value' => t(
              'There is no profile information you can change here. Change your @settings.',
              ['@settings' => $settings_link]
            ),
          ];
        }
        // For other users there's nothing left to do.
        else {
          $form['empty_profile']['notice'] = [
            '#type' => 'html_tag',
            '#tag' => 'p',
            '#value' => t('There is no profile information you can change here.'),
          ];
        }

        $form['actions']['submit']['#disabled'] = TRUE;
      }
    }
  }

  // Add custom submit handler just for redirect purposes. We don't want to
  // override the form::save in profile.
  $form['actions']['submit']['#submit'][] = '_social_profile_profile_edit_form_submit';

  // Add cancel button, so user can easily navigate form edit form to profile.
  $form['actions']['cancel'] = [
    '#type' => 'link',
    '#title' => t('Cancel'),
    '#url' => Url::fromRoute('social_profile.view_user_profile', ['user' => $profile->getOwnerId()]),
  ];
}

/**
 * Form submit for profile_profile_edit_form and profile_profile_add_form.
 *
 * @param array $form
 *   The profile edit form.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state interface.
 */
function _social_profile_profile_edit_form_submit(array $form, FormStateInterface $form_state) {
  /** @var \Drupal\profile\Entity\Profile $profile */
  $profile = $form_state->getFormObject()->getEntity();

  // Let's be on the safe side.
  if ($profile instanceof Profile) {
    // Get the uid of the profile.
    $uid = $profile->getOwnerId();
    // Invalidate cache tag.
    Cache::invalidateTags(['user:breadcrumb:' . $uid]);
    // Set redirect to the profile page when a user saves their profile.
    $form_state->setRedirect(
      'social_profile.view_user_profile', [
        'user' => $uid,
      ]
    );
  }
}

/**
 * Implements hook_local_tasks_alter().
 */
function social_profile_local_tasks_alter(&$local_tasks) {
  // Remove the profile main "Profile information" from the local tabs.
  if (!empty($local_tasks['entity.profile.user_profile_form:profile.type.main'])) {
    unset($local_tasks['entity.profile.user_profile_form:profile.type.main']);
  }
  if (!empty($local_tasks['entity.profile.user_profile_form:profile.type.profile'])) {
    unset($local_tasks['entity.profile.user_profile_form:profile.type.profile']);
  }
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function social_profile_menu_local_tasks_alter(&$data, $route_name) {
  if (isset($data['tabs'][0]['profile.user_page:profile'])) {
    unset($data['tabs'][0]['profile.user_page:profile']);
  }
}

/**
 * Implements hook_preprocess_fieldset().
 */
function social_profile_preprocess_fieldset(&$variables) {
  // Style our checkboxes as nested checkboxes.
  if (isset($variables['element']['#name']) && $variables['element']['#name'] === 'profile_tag') {
    $variables['attributes']['class'][] = 'checkboxes--nested';
  }
}

/**
 * Implements hook_preprocess_input().
 */
function social_profile_preprocess_input(&$variables) {
  // Edit the profile tag displays to show the hierarchy to users.
  // Only do this if it starts with a - to indicate it's a child.
  if (
    !empty($variables['element']['#parents'])
    && $variables['element']['#parents'][0] === 'profile_tag'
    && substr($variables['element']['#title'], 0, 1) === '-'
  ) {
    $variables['element']['#attributes']['class'][] = 'checkboxes--nested__child';
  }
}

/**
 * Implements hook_preprocess_form_element_label().
 */
function social_profile_preprocess_form_element_label(&$variables) {
  // Edit the profile tag displays to show the hierarchy to users.
  // Only do this if it starts with a - to indicate it's a child.
  if (
    isset($variables['element']['#id'])
    && substr($variables['element']['#id'], 0, 17) === 'edit-profile-tag-'
    && substr($variables['element']['#title'], 0, 1) === '-'
  ) {
    $variables['title']['#markup'] = substr($variables['title']['#markup'], 1);
  }
}

/**
 * Implements hook_theme().
 */
function social_profile_theme(): array {
  return [
    'profile__profile__name' => [
      'template' => 'profile--profile--name',
      'render element' => 'elements',
      'base hook' => 'profile',
    ],
  ];
}

/**
 * Implements hook_preprocess_HOOK().
 *
 * Allows modifying link attributes by modules instead of using hardcoded
 * attributes in the theme template.
 */
function social_profile_preprocess_field__field_profile_image(array &$variables): void {
  if ($variables['element']['#view_mode'] === 'compact') {
    $element = &$variables['items'][0]['content'];
    $url = $element['#url'];

    /** @var \Drupal\profile\Entity\ProfileInterface $profile */
    $profile = $variables['element']['#object'];

    $name = $profile->getOwner()->getDisplayName();

    if ($url instanceof Url) {
      $url->mergeOptions([
        'attributes' => ['title' => $name],
      ]);
    }

    $element['#item_attributes']['alt'] = $name;
  }
}

/**
 * Prepares variables for profile templates.
 *
 * Default template: profile.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - elements: An array of elements to display in view mode.
 *   - profile: The profile object.
 *   - view_mode: View mode; e.g., 'full', 'teaser', etc.
 */
function social_profile_preprocess_profile(array &$variables) {
  /** @var \Drupal\profile\Entity\Profile $profile */
  $profile = $variables['profile'];
  $user = $profile->getOwner();
  $current_user = \Drupal::currentUser();

  // See social_user_user_format_name_alter(), DisplayName is either first name
  // + last name, or username if both first and last name aren't filled out.
  $variables['profile_name'] = $user->getDisplayName();
  $variables['profile_contact_url'] = _social_profile_get_contact_url($user);
  $variables['profile_stream_url'] = Url::fromUserInput('/user/' . $profile->getOwnerId() . '/stream');
  $variables['profile_home'] = Url::fromRoute('entity.user.canonical', ['user' => $user->id()]);

  // Set a condition for the label to show in the teaser
  // The actual label text should be changeable in the template.
  // Disable for the LU's own profile.
  $variables['profile_contact_label'] = 'profile_info';
  if (
    \Drupal::moduleHandler()->moduleExists('social_private_message') &&
    $current_user->id() !== $user->id() &&
    $current_user->hasPermission('use private messaging system') &&
    $user->hasPermission('use private messaging system')
  ) {
    $variables['profile_contact_label'] = 'private_message';
    $variables['#cache']['contexts'][] = 'user';
  }

  // Edit profile URL.
  // Get the current route name to check if the user is on the edit or delete
  // page.
  $route = \Drupal::routeMatch()->getRouteName();
  if ($route !== 'profile.user_page.single' && $profile->access('update', $current_user)) {
    $variables['profile_edit_url'] = Url::fromUserInput('/user/' . $profile->getOwnerId() . '/profile');
    $variables['#cache']['contexts'][] = 'route.name';
  }

  // Add the hero styled image if we have access to it.
  if (!empty($profile->field_profile_banner_image->entity) && $profile->field_profile_banner_image->access('view')) {
    $variables['profile_hero_styled_image_url'] = ImageStyle::load('social_xx_large')
      ->buildUrl($profile->field_profile_banner_image->entity->getFileUri());
  }

  // Profile information URL.
  $variables['profile_info_url'] = Url::fromRoute('social_profile.view_user_profile', ['user' => $profile->getOwnerId()]);

  // Prepare variables for statistic block.
  if ($variables['elements']['#view_mode'] === 'statistic') {
    /** @var \Drupal\social_profile\UserStatistics $user_statistics */
    $user_statistics = \Drupal::service('social_profile.user_statistics');
    $variables['profile_topics'] = $user_statistics->nodeCount($user->id(), 'topic');
    $variables['profile_events'] = $user_statistics->nodeCount($user->id(), 'event');
    $variables['profile_groups'] = \Drupal::service('social_group.helper_service')
      ->countGroupMembershipsForUser($user->id());
  }

  /** @var \Drupal\social_profile\SocialProfileTagServiceInterface $tag_service */
  $tag_service = \Drupal::service('social_profile.tag_service');
  $variables['profile_tagging_active'] = $tag_service->isActive();
  $variables['profile_tagging_allow_split'] = $tag_service->allowSplit();

  if (!$profile->get('field_profile_profile_tag')->isEmpty()) {
    $tags = $profile->get('field_profile_profile_tag')->getValue();
    $variables['profile_tagging_hierarchy'] = $tag_service->buildHierarchy($tags);
  }
}

/**
 * Implements hook_entity_field_access().
 */
function social_profile_entity_field_access(string $operation, FieldDefinitionInterface $field_definition, AccountInterface $account, FieldItemListInterface $items = NULL) : AccessResultInterface {
  /** @var \Drupal\social_profile\FieldManager $field_manager */
  $field_manager = \Drupal::service('social_profile.field_manager');

  // We manage access for any profile field that hasn't explicitly opted out.
  if ($field_definition->getTargetEntityTypeId() === 'profile' && !$field_manager::isOptedOutOfFieldAccessManagement($field_definition)) {
    return social_profile_entity_social_managed_field_access($operation, $field_definition, $account, $items);
  }

  // Users manage the visibility of their e-mail using their profile. Email
  // display on the profile happens by copying the value to the profile itself.
  // However the email may also be accessed on the user entity directly, for
  // example in the GraphQL API. To ensure that the email is also protected
  // through that path we apply the profile's access determination to the
  // User.email field. Currently we offer no way for a user to modify the
  // profile they share with the community separately from their account email.
  // When we do add that in the future we may want to implement stricter account
  // permission checks and keep the profile access checks only for the profile
  // email field (which the user should then be able to configure).
  // The settings for other operations also respect those as configured for the
  // profile email, to accommodate e.g. disabling editing of email for SSO
  // integrations. That would need to be preserved in a refactor.
  if ($field_definition->getTargetEntityTypeId() === 'user' && $field_definition->getName() === 'mail') {
    // Type annotation needed until Drupal 9.2.0.
    /** @var \Drupal\field\FieldConfigInterface|NULL $profile_field_definition */
    $profile_field_definition = FieldConfig::loadByName('profile', 'profile', 'field_profile_email');
    if ($profile_field_definition === NULL) {
      return AccessResult::neutral("Field 'field_profile_email' is not installed.");
    }

    $user_items = NULL;
    if ($items !== NULL) {
      /** @var \Drupal\profile\ProfileStorageInterface $profile_storage */
      $profile_storage = \Drupal::service('entity_type.manager')
        ->getStorage('profile');
      /** @var \Drupal\user\UserInterface $user */
      $user = $items->getEntity();
      $profile = $profile_storage->loadByUser($user, 'profile');

      if ($profile === NULL) {
        return AccessResult::neutral("User has no profile so can not perform email access management.");
      }

      $user_items = $profile->get('field_profile_email');
    }

    return social_profile_entity_social_managed_field_access($operation, $profile_field_definition, $account, $user_items);
  }

  return AccessResult::neutral();
}

/**
 * Handles field access checks for managed fields.
 *
 * Implements hook_entity_field_access though it contains only logic for fields
 * that have not explicitly opted out of access management.
 *
 * This is currently only used for profiles but is abstract enough that it could
 * be moved to social_core and used for other entity types too.
 *
 * @param string $operation
 *   The operation to be performed. See
 *   \Drupal\Core\Entity\EntityAccessControlHandlerInterface::fieldAccess()
 *   for possible values.
 * @param \Drupal\Core\Field\FieldDefinitionInterface $field_definition
 *   The field definition.
 * @param \Drupal\Core\Session\AccountInterface $account
 *   The user account to check.
 * @param \Drupal\Core\Field\FieldItemListInterface $items
 *   (optional) The entity field object for which to check access, or NULL if
 *   access is checked for the field definition, without any specific value
 *   available. Defaults to NULL.
 *
 * @return \Drupal\Core\Access\AccessResultInterface
 *   The access result.
 */
function social_profile_entity_social_managed_field_access(string $operation, FieldDefinitionInterface $field_definition, AccountInterface $account, FieldItemListInterface $items = NULL) : AccessResultInterface {
  $entity_type = $field_definition->getTargetEntityTypeId();
  $entity_bundle = $field_definition->getTargetBundle();
  $field_name = $field_definition->getName();
  /** @var \Drupal\social_profile\FieldManager $field_manager */
  $field_manager = \Drupal::service('social_profile.field_manager');
  /** @var \Drupal\Core\Entity\EntityStorageInterface $storage */
  $storage = \Drupal::service('entity_type.manager')->getStorage($entity_type);

  if ($operation === 'view') {
    // Bypass more complex access checks if a user is viewing their own profile
    // and can see that field.
    if ($items !== NULL) {
      $entity = $items->getEntity();
      if ($entity instanceof EntityOwnerInterface && $entity->getOwnerId() === $account->id()) {
        // We're okay with the user seeing this but we defer to other modules
        // for possibly restricting.
        return AccessResult::neutral();
      }
    }

    // Allow bypassing complex checks if a profile is being viewed by a user
    // with access bypass permissions.
    $result = AccessResult::allowedIfHasPermission($account, "view any ${entity_type} fields")
      ->orIf(AccessResult::allowedIfHasPermission($account, "view any ${entity_bundle} ${entity_type} fields"));

    if ($result->isAllowed()) {
      return $result;
    }
  }

  // We have no opinion about viewing a visibility field value.
  if ($operation === "view" && !$field_manager::isManagedValueField($field_definition)) {
    return AccessResult::neutral();
  }
  // For value fields we must check if the entity owner is allowed to set the
  // visibility themselves. Depending on that we look either at the value
  // contained in the visibility field or use the default setting provided by
  // the site manager.
  if ($operation === "view") {
    /** @var string $visibility_stored_by */
    $visibility_stored_by = $field_manager::getVisibilityFieldName($field_definition);

    // If there's no item we're actually checking for then we use the default
    // value.
    if ($items === NULL) {
      // To check the default value we just create a new profile entity.
      /** @var \Drupal\Core\Entity\FieldableEntityInterface $entity */
      $entity = $storage->create(['type' => $entity_bundle]);
      $depends_on_profile_value = FALSE;
    }
    // Otherwise we get the entity the item belongs to and use it if the
    // owner of the entity is allowed to alter visibility.
    else {
      /** @var \Drupal\Core\Entity\FieldableEntityInterface $entity */
      $entity = $items->getEntity();
      $entity_owner = $entity instanceof EntityOwnerInterface ? $entity->getOwner() : NULL;
      $depends_on_profile_value = TRUE;

      // If the user can't change the visibility then we also check against a
      // dummy entity so that we use the default value set by a site manager.
      // This ensures that if a site manager re-enables user configuration
      // that the value the user had previously set is respected again.
      if ($entity_owner === NULL || !$entity_owner->hasPermission("edit own ${visibility_stored_by} ${entity_bundle} ${entity_type} field")) {
        /** @var \Drupal\Core\Entity\FieldableEntityInterface $entity */
        $entity = $storage->create(['type' => $entity_bundle]);
        $depends_on_profile_value = FALSE;
      }
    }

    if (!$entity->hasField($visibility_stored_by)) {
      return AccessResult::neutral("Visibility for {$field_definition->getName()} is stored in {visibility_stored_by} but that field does not exist.");
    }

    $field_visibility = $entity->get($visibility_stored_by)->value;
    switch ($field_visibility) {
      case SOCIAL_PROFILE_FIELD_VISIBILITY_PUBLIC:
        $result = AccessResult::allowed();
        break;

      case SOCIAL_PROFILE_FIELD_VISIBILITY_COMMUNITY:
        $result = AccessResult::allowedIfHasPermission($account, "view " . SOCIAL_PROFILE_FIELD_VISIBILITY_COMMUNITY . " ${entity_bundle} ${entity_type} fields")
          ->orIf(AccessResult::allowedIfHasPermission($account, "view " . SOCIAL_PROFILE_FIELD_VISIBILITY_COMMUNITY . " profile fields"));
        break;

      case SOCIAL_PROFILE_FIELD_VISIBILITY_FRIENDS:
        // Unsupported access type would have an additional dependency on the
        // friend relationship between the entity owner and viewer. However,
        // being unsupported it has no cache dependencies and can be cached
        // forever.
        return AccessResult::forbidden("Friends visibility access checks are not yet implemented. This is an illegal visibility field value.");

      case SOCIAL_PROFILE_FIELD_VISIBILITY_PRIVATE:
        $result = AccessResult::allowedIfHasPermission($account, "view " . SOCIAL_PROFILE_FIELD_VISIBILITY_PRIVATE . " ${field_name} ${entity_bundle} ${entity_type} fields");
        break;

      default:
        $result = AccessResult::neutral("Unknown visibility field value '${field_visibility}'.");
    }

    // Result always depends on either the permissions of the viewing user or
    // those of the entity owner.
    $result->cachePerPermissions();

    // Sometimes it depends on the value of the visibility field on the entity
    // itself.
    if ($depends_on_profile_value) {
      $result->addCacheableDependency($entity);
    }

    // Fields are allowed by default in Drupal. However, unless the user has
    // express permission to view managed fields then we want to deny. Thus we
    // convert neutral to forbidden using andIf so that we keep the
    // cacheability metadata and the reason from the actual permission check.
    if ($result->isNeutral()) {
      $result = $result->andIf(AccessResult::forbidden());
    }

    return $result;
  }

  if ($operation === 'edit') {
    // If a user doesn't have express permission to edit a field then we must
    // forbid it.
    $permissions = [
      "edit any ${field_name} ${entity_bundle} ${entity_type} field",
    ];

    // If there is an item we can check if it belongs to the user.
    if ($items !== NULL) {
      /** @var \Drupal\Core\Entity\FieldableEntityInterface $entity */
      $entity = $items->getEntity();
      $entity_owner = $entity instanceof EntityOwnerInterface ? $entity->getOwner() : NULL;

      if ($entity_owner !== NULL && $entity_owner->id() === $account->id()) {
        $permissions[] = "edit own ${field_name} ${entity_bundle} ${entity_type} field";
      }
    }

    $result = AccessResult::allowedIfHasPermissions($account, $permissions, "OR");

    // If an entity was checked we must add it as a dependency for the
    // permission checks because viewing a different entity requires different
    // checks.
    if (isset($entity)) {
      $result->addCacheableDependency($entity);
    }

    // Fields are allowed by default in Drupal. However, unless the user has
    // express permission to change managed fields then we want to deny. Thus we
    // convert neutral to forbidden using andIf so that we keep the
    // cacheability metadata and the reason from the actual permission check.
    if ($result->isNeutral()) {
      $result = $result->andIf(AccessResult::forbidden());
    }

    return $result;
  }

  return AccessResult::neutral("Unknown operation '${operation}'.");
}

/**
 * Get the contact URL. This can be private message or other means of contact.
 *
 * @param \Drupal\user\UserInterface $account
 *   The user object.
 *
 * @return \Drupal\Core\Url
 *   The URL to contact the user.
 */
function _social_profile_get_contact_url(UserInterface $account) {
  if (\Drupal::moduleHandler()->moduleExists('social_private_message')) {
    $current_user = \Drupal::currentUser();
    if ($current_user->hasPermission('use private messaging system') && $account->hasPermission('use private messaging system') && $current_user->id() != $account->id()) {
      $members = [$current_user, $account];
      $thread_id = \Drupal::service('private_message.mapper')
        ->getThreadIdForMembers($members);
      if ($thread_id) {
        $url = Url::fromRoute('entity.private_message_thread.canonical', ['private_message_thread' => $thread_id], ['attributes' => ['class' => ['private_message_link']]]);
        if ($url->access($current_user)) {
          return $url;
        }
      }
      return Url::fromRoute('private_message.private_message_create', [], ['query' => ['recipient' => $account->id()]]);
    }
  }
  return Url::fromUserInput('/user/' . $account->id() . '/information');
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function social_profile_user_insert(UserInterface $user) {
  social_profile_ensure_default_user_profile($user);
}

/**
 * Ensures that a default profile exists for the user.
 *
 * Many functions in Open Social expect the user to have a default profile.
 * Depending on how the user is created the profile module itself may or may not
 * create a user profile. This function ensures such profile exists.
 *
 * @param \Drupal\user\UserInterface $user
 *   The user to check or create a profile for, must be a user that is persisted
 *   to the database. The anonymous user is ignored.
 *
 * @return \Drupal\profile\Entity\ProfileInterface
 *   The existing or created user profile. In case the anonymous user was passed
 *   in an unsaved profile is returned.
 */
function social_profile_ensure_default_user_profile(UserInterface $user) : ProfileInterface {
  // If the user is not saved yet we can't create a profile.
  if ($user->id() === NULL) {
    throw new InvalidArgumentException("The user must be saved before a profile can be created.");
  }

  $profile_type_id = 'profile';
  /** @var \Drupal\profile\Entity\ProfileTypeInterface|NULL $profile_type */
  $profile_type = ProfileType::load($profile_type_id);
  if ($profile_type === NULL) {
    throw new RuntimeException("The 'profile' profile type is required for Open Social to function.");
  }

  /** @var \Drupal\profile\ProfileStorageInterface $profile_storage */
  $profile_storage = \Drupal::entityTypeManager()->getStorage('profile');

  // We must use the computed field here rather than querying the database
  // because this code might run after the ProfileFormWidget has created the
  // profile, but before they have been saved to the database. This avoids
  // creating a duplicate profile unnecessarily.
  /** @var ?\Drupal\profile\Entity\ProfileInterface $profile */
  $profile = $user->get("profile_profiles")->entity;

  // Only create the profile if the user does not already have one.
  if ($profile === NULL) {
    /** @var \Drupal\profile\Entity\ProfileInterface $profile */
    $profile = $profile_storage->create([
      'type' => $profile_type_id,
      'uid' => $user->id(),
    ]);

    // We don't store the profile for the anonymous user since by default in
    // Open Social we don't want that user to have a profile. However, we still
    // return the unsaved profile to make the type-checking easier for calling
    // code.
    if (!$user->isAnonymous()) {
      $profile->save();
    }
  }

  return $profile;
}

/**
 * Implements hook_ENTITY_TYPE_update().
 */
function social_profile_user_update(UserInterface $user) : void {
  /** @var \Drupal\profile\ProfileStorageInterface $profile_storage */
  $profile_storage = \Drupal::entityTypeManager()->getStorage('profile');
  $profile = $profile_storage->loadByUser($user, 'profile');

  // Only update the profile if the user has a profile.
  if ($profile !== NULL) {
    $has_changed = social_profile_copy_shared_user_data_to_profile($user, $profile);
    // Skip saving the profile if nothing actually changed. This prevents
    // unnecessary noise for other modules who may be listening to profile
    // updates.
    if ($has_changed) {
      $profile->save();
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 */
function social_profile_profile_presave(ProfileInterface $profile) : void {
  // Copy any data from the user to the profile. We do this in a profile
  // pre-save rather than on user update to account for the scenario where an
  // embedded profile form on a user form will overwrite some of our own
  // changes.
  social_profile_copy_shared_user_data_to_profile($profile->getOwner(), $profile);
}

/**
 * Copies data from the user entity to the profile for shared fields.
 *
 * Some data for users such as email and langcode should be displayed on the
 * users profile depending on user configuration. Managing all this display data
 * in a single entity is easier for access and display but the data is owned by
 * the user entity, so rather than edit it directly this function synchronizes
 * it from the user entity to the profile.
 *
 * @param \Drupal\user\UserInterface $user
 *   The user to synchronize data for.
 * @param \Drupal\profile\Entity\ProfileInterface $profile
 *   The profile entity to synchronize data to.
 *
 * @return bool
 *   Whether the profile entity has been modified.
 */
function social_profile_copy_shared_user_data_to_profile(UserInterface $user, ProfileInterface $profile) : bool {
  $has_changed = FALSE;

  if (!$profile->hasField('field_profile_email') || !$profile->hasField('field_profile_preferred_language')) {
    // Depending on the 11.x version people are upgrading from, the update hook
    // may contain updates to the user entity triggering this function but the
    // hook creating the fields may not have run yet, so we must skip the
    // synchronization in that case.
    // @todo Change this early return into a hard error in 13.0.0 indicating
    // that Open Social is not properly installed.
    return $has_changed;
  }

  $user_email = $user->getEmail();
  if ((!$current_email = $profile->get('field_profile_email')->first()) || $current_email->getValue() !== $user_email) {
    $profile->set('field_profile_email', $user_email, FALSE);
    $has_changed = TRUE;
  }

  $user_preferred_language = $user->getPreferredLangcode();
  if ((!$current_preferred_language = $profile->get('field_profile_preferred_language')->first()) || $current_preferred_language->getValue() !== $user_preferred_language) {
    $profile->set('field_profile_preferred_language', $user_preferred_language, FALSE);
    $has_changed = TRUE;
  }

  return $has_changed;
}

/**
 * Implements hook_entity_bundle_field_info_alter().
 */
function social_profile_entity_bundle_field_info_alter(array &$fields, EntityTypeInterface $entity_type, string $bundle) : void {
  if ($entity_type->id() === 'profile' && $bundle === 'profile') {
    $config = \Drupal::config('social_profile.settings');

    // Add the unique nickname constraint if it's enabled and the field exists.
    if (isset($fields['field_profile_nick_name']) && $config->get('nickname_unique_validation')) {
      $fields['field_profile_nick_name']->addConstraint('UniqueNickname', []);
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function social_profile_form_user_form_alter(&$form, FormStateInterface $form_state) {
  $form['#pre_render'][] = [SocialProfileUserFormAlter::class, 'preRender'];
}

/**
 * Gets the users profile by route.
 *
 * @return mixed
 *   The profile or NULL if nothing could be found.
 */
function _social_profile_get_profile_from_route() {
  $profile = NULL;
  $entity_type_manager = \Drupal::entityTypeManager();

  $account = \Drupal::routeMatch()->getParameter('user');
  if (!is_object($account) && !is_null($account)) {
    $account = $entity_type_manager
      ->getStorage('user')
      ->load($account);
  }

  if (!empty($account)) {
    $storage = $entity_type_manager->getStorage('profile');
    $profile = $storage->loadByUser($account, 'profile');
  }

  return $profile;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function social_profile_form_user_register_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Set User Register form Email field as required.
  $form['account']['mail']['#required'] = TRUE;

  // Move the profile fields form into the account block.
  if (isset($form['profile_profiles'])) {
    $form['account']['profile_profiles'] = $form['profile_profiles'];
    unset($form['profile_profiles']);
  }
}

/**
 * Implements hook_ENTITY_TYPE_view_alter().
 */
function social_profile_profile_view_alter(array &$build, EntityInterface $entity, EntityViewDisplayInterface $display) {
  $image_item = $build['field_profile_image'][0]['#item'] ?? NULL;

  // Image doesn't exists.
  if (!($image_item instanceof FieldItemInterface)) {
    return;
  }

  /** @var \Drupal\Core\Session\AccountProxy $current_user */
  $current_user = \Drupal::currentUser();

  // If the current user has no access to viewing user profiles, it might not
  // have access to the users profile.
  if (!$current_user->hasPermission('view any profile profile') &&
    isset($display->get('content')['field_profile_image'])
  ) {

    // Try to load the profile picture.
    $image = $entity->get('field_profile_image')->entity;

    // Must have a value and not be NULL.
    if ($image instanceof FileInterface) {
      // Potentially the file is in the private file system. In that case,
      // anonymous user don't have access to it.
      $file_scheme = \Drupal::service('stream_wrapper_manager')->getScheme($image->getFileUri());
      if ($file_scheme === 'private') {
        // Load default data.
        $replacement_data = social_profile_get_default_image();
        // Time to override the data that going to be rendered.
        $image_item->set('target_id', $replacement_data['id']);
        $image_item->set('width', $replacement_data['width']);
        $image_item->set('height', $replacement_data['height']);
        // Put replacement data back in the object that's about to be built.
        $build['field_profile_image'][0]['#item'] = $image_item;
      }
    }
  }
}

/**
 * Function to fetch the default profile image.
 */
function social_profile_get_default_image() {
  // Load default image.
  $config_factory = \Drupal::configFactory();
  $field_image_config = $config_factory->getEditable('field.field.profile.profile.field_profile_image');
  $default_image = $field_image_config->get('settings.default_image');
  // Load by uuid.
  $files = \Drupal::entityTypeManager()
    ->getStorage('file')
    ->loadByProperties(['uuid' => $default_image['uuid']]);
  // Pop it.
  $file = array_pop($files);
  // Set in an array.
  $data = [
    "id" => $file->id(),
    "width" => $default_image['width'],
    "height" => $default_image['height'],
  ];
  // Retun the array.
  return $data;
}

/**
 * Implements hook_social_user_name_display_suggestions().
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
 */
function social_profile_social_user_name_display_suggestions(AccountInterface $account): array {
  $suggestions = [];

  $entityTypeManager = \Drupal::entityTypeManager();
  $settings = \Drupal::config('social_profile.settings');

  /** @var \Drupal\profile\ProfileStorageInterface $storage */
  $storage = $entityTypeManager->getStorage('profile');
  assert($storage instanceof ProfileStorageInterface);

  $profile = $storage->loadByUser($account, 'profile');

  // We expect all users to have a profile, not having one means Open Social is
  // incorrectly installed. However, we can't continue without one.
  if ($profile === NULL) {
    \Drupal::logger('social_profile')->error("Missing default 'profile' profile for user ({$account->id()}).");
    return $suggestions;
  }

  // Full name.
  $first_name_field = $profile->get('field_profile_first_name');
  $first_name_field_definition = $first_name_field->getFieldDefinition();
  assert($first_name_field_definition instanceof FieldConfigInterface);
  $last_name_field = $profile->get('field_profile_last_name');
  $last_name_field_definition = $last_name_field->getFieldDefinition();
  assert($last_name_field_definition instanceof FieldConfigInterface);

  $first_name = $first_name_field_definition->status() && $first_name_field->access('view') ? $first_name_field->getString() : "";
  $last_name = $last_name_field_definition->status() && $last_name_field->access('view') ? $last_name_field->getString() : "";

  $account_name = trim($first_name . " " . $last_name);
  if ($account_name !== '') {
    // Add the full name with a default weight.
    $suggestions['full_name'] = [
      'name' => $account_name,
    ];
  }

  // Nickname.
  $nick_name_field = $profile->get('field_profile_nick_name');
  $nick_name_field_definition = $nick_name_field->getFieldDefinition();
  assert($nick_name_field_definition instanceof FieldConfigInterface);

  $nickname = $nick_name_field_definition->status() &&  $nick_name_field->access('view') ? $nick_name_field->getString() : "";
  if ($nickname !== '') {
    // Add the nickname with a low weight, so it's shown before the full name.
    $suggestions['nickname'] = [
      'weight' => -100,
      'name' => $nickname,
    ];
  }

  if (
    $settings->get('limit_name_display')
    && isset($suggestions['full_name'], $suggestions['nickname'])
    && \Drupal::currentUser()->hasPermission('social profile always show full name')
  ) {
    $suggestions['nickname_with_full_name'] = [
      'weight' => -PHP_INT_MAX,
      'name' => $suggestions['nickname']['name'] . ' (' . $suggestions['full_name']['name'] . ')',
    ];
  }

  return $suggestions;
}

/**
 * Hide timezone fields group label.
 */
function _social_profile_form_pre_render($element) {
  $element['group_locale_settings']['timezone']['#title'] = NULL;
  return $element;
}

/**
 * Implements hook_entity_operation_alter().
 */
function social_profile_entity_operation_alter(array &$operations, EntityInterface $entity) {
  if ($entity->getEntityTypeId() === 'user') {
    if (isset($operations['edit'])) {
      $operations['edit']['title'] = t('Edit account');
      $operations['edit_profile'] = [
        'title' => t('Edit profile'),
        'weight' => (isset($operations['edit']['weight'])) ? $operations['edit']['weight']-- : 0,
        'url' => Url::fromUserInput('/user/' . $entity->id() . '/profile'),
      ];
    }
  }
}

/**
 * Implements hook_social_user_account_header_account_links().
 *
 * Adds the "View my profile" and "Edit profile" link to the user menu.
 */
function social_profile_social_user_account_header_account_links(array $context) {
  // We require a user for these links.
  if (empty($context['user']) || !($context['user'] instanceof AccountInterface)) {
    return [];
  }

  return [
    'my_profile' => [
      '#type' => 'link',
      '#attributes' => [
        'title' => new TranslatableMarkup('View my profile'),
      ],
      '#title' => new TranslatableMarkup('My profile'),
      '#weight' => 500,
    ] + Url::fromRoute('user.page')->toRenderArray(),
    'edit_profile' => [
      '#type' => 'link',
      '#attributes' => [
        'title' => new TranslatableMarkup("Edit profile"),
      ],
      '#title' => new TranslatableMarkup("Edit profile"),
      '#weight' => 1300,
    ] + Url::fromRoute('profile.user_page.single', [
      'user' => $context['user']->id(),
      'profile_type' => 'profile',
    ])->toRenderArray(),
  ];
}

/**
 * Implements hook_social_user_account_header_items_alter().
 *
 * Replaces the default user icon with the user's profile image if available.
 */
function social_profile_social_user_account_header_items_alter(array &$menu_items, array $context) {
  // If we don't have an account_box there's nothing to do.
  if (empty($menu_items['account_box'])) {
    return;
  }

  // A user is required to find the profile image.
  if (empty($context['user']) || !($context['user'] instanceof AccountInterface)) {
    return;
  }

  $storage = \Drupal::entityTypeManager()->getStorage('profile');
  $profile = $storage->loadByUser($context['user'], 'profile');

  // If the user does not have a profile then there's no profile image.
  if (empty($profile)) {
    return;
  }

  // Provide a render array as image which will overrule the user icon.
  $menu_items['account_box']['#image'] = \Drupal::entityTypeManager()
    ->getViewBuilder('profile')
    ->view($profile, 'small');
}

/**
 * Implements hook_ENTITY_TYPE_access().
 */
function social_profile_profile_access(ProfileInterface $profile, string $operation, AccountInterface $account) : AccessResultInterface {
  // Users may only view profiles if they are also allowed to view the user that
  // the profile belongs to. This ensures that profiles for blocked users or
  // unverified users are hidden from the right people.
  // We don't apply the same logic for other operations because it may be
  // desirable to let a certain role edit user profile data without editing a
  // user's personal settings.
  if ($operation === 'view') {
    $user_access = $profile->getOwner()->access($operation, $account, TRUE);
    if ($user_access->isNeutral()) {
      // Profile is allowed by default whereas a user may be denied for neutral
      // so we must convert neutral to forbidden while preserving cache info.
      $user_access = $user_access->andIf(AccessResult::forbidden());
    }
    if ($user_access->isForbidden()) {
      return $user_access;
    }
  }

  return AccessResult::neutral();
}

/**
 * Implements hook_entity_form_display_alter().
 */
function social_profile_entity_form_display_alter(EntityFormDisplayInterface $form_display, array $context) {
  if ($form_display->id() === 'profile.profile.default') {
    $content = $form_display->get('content');
    if (isset($content['field_profile_profile_tag'])) {
      $content['field_profile_profile_tag']['type'] = 'social_profile_tag_split';
      $form_display->set('content', $content);
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function social_profile_form_taxonomy_overview_terms_alter(&$form, FormStateInterface $form_state, $form_id) {
  if (\Drupal::service('social_profile.tag_service')->allowSplit()) {
    $storage = $form_state->getStorage();
    /** @var \Drupal\taxonomy\Entity\Vocabulary $vocabulary */
    $vocabulary = $storage['taxonomy']['vocabulary'];

    if ($vocabulary->id() === 'profile_tag') {
      // Remove edit/delete links.
      foreach (Element::children($form['terms']) as $name) {
        unset($form['terms'][$name]['weight']);
      }

      // Hide Save button.
      $form['actions']['submit']['#access'] = FALSE;

      // Remove tableDrag.
      unset($form['terms']['#tabledrag']);

      // Remove Weight column.
      unset($form['terms']['#header'][1]);
    }
  }
}

/**
 * Implements hook_views_plugins_filter_alter().
 */
function social_profile_views_plugins_filter_alter(array &$plugins) {
  $plugins['search_api_term']['class'] = SocialSearchApiSplitProfileTerms::class;
}

/**
 * Implements hook_social_core_default_main_menu_links_alter().
 */
function social_profile_social_core_default_main_menu_links_alter(array &$links) {
  $link = \Drupal::entityTypeManager()->getStorage('menu_link_content')
    ->loadByProperties([
      'title' => 'All members',
      'menu_name' => 'main',
      'link' => 'internal:/all-members',
    ]);
  $link = end($link);

  // Ensure that the end() doesn't return FALSE, and we have link instance.
  if ($link instanceof MenuLinkContentInterface) {
    $links[] = $link;
  }
}

/**
 * Implements hook_social_tagging_type().
 */
function social_profile_social_tagging_type(): string {
  return 'profile';
}
