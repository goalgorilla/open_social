<?php

/**
 * @file
 * Installation file for Social Tagging.
 */

use Drupal\block\Entity\Block;
use Drupal\Core\Config\FileStorage;
use Drupal\Core\Entity\Display\EntityFormDisplayInterface;
use Drupal\Core\Entity\Entity\EntityViewDisplay;
use Drupal\Core\Entity\Entity\EntityViewMode;
use Drupal\Core\StringTranslation\TranslatableMarkup;
use Drupal\field\Entity\FieldConfig;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\search_api\Entity\Index;
use Drupal\search_api\Item\Field;

/**
 * Install the module.
 */
function social_tagging_install(): void {
  // Grant the default permissions for this feature.
  user_role_grant_permissions(
    'sitemanager',
    [
      'administer social_tagging',
      'delete terms in social_tagging',
      'edit terms in social_tagging',
    ]
  );

  // Ensure tagging data is indexed in our search index.
  _social_tagging_update_search_index_for_tagging();
}

/**
 * Uninstall the module.
 */
function social_tagging_uninstall(): void {
  // Remove the search api fields.
  _social_tagging_remove_fields_search_api();
}

/**
 * Add fields to search API.
 */
function _social_tagging_add_fields_search_api(): void {

}

/**
 * Remove fields from search API.
 */
function _social_tagging_remove_fields_search_api(): void {
  // @todo REIMPLEMENT THIS
}

/**
 * Implements hook_update_last_removed().
 */
function social_tagging_update_last_removed() : int {
  // Removed all update hooks that tried to install the old field type.
  return 11501;
}

/**
 * Add a new field to social tagging.
 */
function social_tagging_update_11801(): void {
  $config_path = \Drupal::service('extension.list.module')->getPath('social_tagging') . '/config/static';
  $source = new FileStorage($config_path);
  $entity_type_manager = \Drupal::entityTypeManager();

  /** @var \Drupal\Core\Config\Entity\ConfigEntityStorageInterface $field_storage_config_storage */
  $field_storage_config_storage = $entity_type_manager->getStorage('field_storage_config');

  // Create field storages.
  /** @var \Drupal\Core\Field\FieldTypePluginManagerInterface $field_type_manager */
  $field_type_manager = \Drupal::service('plugin.manager.field.field_type');
  $data = $source->read('field.storage.taxonomy_term.field_term_page_url_11801');
  if (is_array($data)) {
    /** @var \Drupal\Core\Field\FieldItemInterface $class */
    $class = $field_type_manager->getPluginClass($data['type']);
    if (is_null($field_storage_config_storage->load($data['id']))) {
      $data['settings'] = $class::storageSettingsFromConfigData($data['settings']);
      $field_storage_config_storage->create($data)->save();
    }
  }

  // Create field settings.
  /** @var \Drupal\Core\Config\Entity\ConfigEntityStorageInterface $field_config_storage */
  $field_config_storage = $entity_type_manager->getStorage('field_config');
  $data = $source->read('field.field.taxonomy_term.social_tagging.field_term_page_url_11801');
  if (is_array($data) && is_null($field_config_storage->load($data['id']))) {
    $field_config_storage->create($data)->save();
  }

  // Create/update a form/view display for the 'Social tagging' terms.
  $displays = [
    'entity_form_display',
    'entity_view_display',
  ];

  foreach ($displays as $display) {
    $display_storage = $entity_type_manager->getStorage($display);
    $data = $source->read("core.$display.taxonomy_term.social_tagging.default_11801");
    if (is_array($data)) {
      if (is_null($display_storage->load($data['id']))) {
        $display_storage->create($data)->save();
      }
      else {
        /** @var \Drupal\Core\Entity\Display\EntityFormDisplayInterface $view_display */
        $view_display = $display_storage->load($data['id']);
        $view_display->setComponent('field_term_page_url', $data['content']['field_term_page_url']);
        $view_display->save();
      }
    }
  }
}

/**
 * Move social_tagging field to a Field API field.
 */
function social_tagging_update_12000() : void {
  $settings = \Drupal::configFactory()->getEditable("social_tagging.settings");

  // We've decided that as of 12.0.0 we will always enable category splitting
  // and remove the setting. It was the original intention of the feature and
  // emulating non-split mode can be easily done by creating a single hierarchy.
  // This allows us to simplify a lot of our code.
  // Similarly, we no longer allow selection of the category parent but just fix
  // our filters instead.
  $form_widget = [
    "type" => "social_tag_split",
    "settings" => [],
    "region" => "content",
  ];

  // Security: This array should only be static SQL-safe values.
  $entity_types = [
    'node' => [
      'book',
      'event',
      'page',
      'topic',
      'landing_page',
    ],
    'group' => [
      'flexible_group',
      'secret_group',
      'closed_group',
      'open_group',
      'public_group',
    ],
    'profile' => [
      'profile',
    ],
  ];

  foreach ($entity_types as $entity_type => $bundles) {
    $storage = FieldStorageConfig::create([
      'field_name' => "field_social_tagging",
      'entity_type' => $entity_type,
      'type' => 'entity_reference',
      'module' => 'social_tagging',
      'cardinality' => FieldStorageConfig::CARDINALITY_UNLIMITED,
      'translatable' => FALSE,
      'settings' => [
        'target_type' => 'taxonomy_term',
      ],
    ]);
    $storage->save();
    foreach ($bundles as $bundle) {
      try {
        $field = FieldConfig::create([
          'field_storage' => $storage,
          'bundle' => $bundle,
          'label' => new TranslatableMarkup('Tagging'),
          'description' => new TranslatableMarkup('A shared taxonomy between the different types of data in Open Social.'),
          'required' => FALSE,
          'translatable' => FALSE,
          'settings' => [
            'handler' => 'default:taxonomy_term',
            'handler_settings' => [
              'target_bundles' => [
                'social_tagging' => 'social_tagging',
              ],
              'sort' => [
                'field' => 'name',
                'direction' => 'asc',
              ],
              'auto_create' => FALSE,
              'auto_create_bundle' => '',
            ],
          ],
          'field_type' => 'entity_reference',
        ]);

        // Migrate the status for individual bundles.
        $status = $settings->get("tag_${entity_type}_type_{$bundle}");
        if ($status !== NULL && !$status) {
          $field->setStatus(FALSE);
        }
        $settings->clear("tag_${entity_type}_type_{$bundle}");
        $field->save();

        // Update the form display mode to ensure the tag is positioned
        // correctly. We can ignore the view display since tags are displayed in
        // blocks next to the primary content, so the default of hidden is fine.
        $form_display_storage = \Drupal::entityTypeManager()->getStorage("entity_form_display");
        $form_display = $form_display_storage->load("${entity_type}.${bundle}.default");
        assert($form_display instanceof EntityFormDisplayInterface, "${entity_type}.${bundle} doesn't have a default form display.");
        // Position the field in the right place on the form and give it the
        // right widget based on module settings.
        $form_display->setComponent(
          "field_social_tagging",
          $form_widget + [
            "weight" => $form_display->getComponent("social_tagging")["weight"] ?? 3,
          ]
        );
        $form_display->removeComponent("social_tagging");
        // Ensure the tag is in the tags field group and remove the old field if
        // it's present.
        $field_group = $form_display->getThirdPartySetting(
          "field_group",
          "group_social_tags",
          [
            "children" => [],
            "parent_name" => '',
            "weight" => 1,
            "label" => "Tags",
            "format_type" => "fieldset",
            "format_settings" => [
              "required_fields" => TRUE,
              "id" => "tags",
              "classes" => "card",
              "label" => "Tags",
            ],
            "region" => "content",
          ]
        );
        // Change anything that may be in the stored version.
        $field_group["region"] = "content";
        $field_group["children"][] = "field_social_tagging";
        $field_group["children"] = array_filter($field_group["children"], fn ($f) => $f !== "social_tagging");
        $form_display->setThirdPartySetting("field_group", "group_social_tags", $field_group);

        $form_display->save();
      }
      // Mute exceptions thrown by bundles not being installed. Thrown in
      // \Drupal\Core\Entity\EntityType:getBundleConfigDependency when we try to
      // create the field.
      catch (\LogicException $e) {
      }
    }

    // Migrate all the data from the old field directly in the database, this is
    // more performant than loading all the entities.
    // Security: This does not pose a SQL injection threat because the inserted
    // variable only ever contains static values set earlier in this function.
    \Drupal::database()->query("INSERT INTO ${entity_type}__field_social_tagging SELECT bundle, deleted, entity_id, revision_id, langcode, delta, social_tagging_target_id as field_social_tagging_target_id FROM ${entity_type}__social_tagging ");
    if ($entity_type === "node" || $entity_type === "profile") {
      \Drupal::database()->query("INSERT INTO ${entity_type}_revision__field_social_tagging SELECT bundle, deleted, entity_id, revision_id, langcode, delta, social_tagging_target_id as field_social_tagging_target_id FROM ${entity_type}_revision__social_tagging");
    }

    foreach ($bundles as $bundle) {
      FieldConfig::load("$entity_type.$bundle.social_tagging")?->delete();
    }

    FieldStorageConfig::load("$entity_type.social_tagging")?->delete();
  }

  // This update hook runs after the search indices have been merged, so we only
  // need to update the social_all index.
  $index = Index::load("social_all");
  assert($index !== NULL, "Missing 'social_all' index which points to a corrupt Open Social installation.");
  $index->removeField("social_tagging");
  $field = new Field($index, "social_tagging");
  $field
    ->setLabel("Tagging")
    ->setPropertyPath("aggregated_field")
    ->setType("string")
    ->setConfiguration([
      "type" => "union",
      "fields" => [
        "entity:group/field_social_tagging",
        "entity:node/field_social_tagging",
        "entity:profile/field_social_tagging",
      ],
    ]);
  $index->addField($field);
  if (!$index->isValidProcessor("aggregated_field")) {
    $index->addProcessor(
      \Drupal::getContainer()
        ->get('search_api.plugin_helper')
        ->createProcessorPlugin($index, "aggregated_field")
    );
  }
  $index->save();

  // Remove the things from settings that are now in the widget config.
  $settings
    ->clear("allow_category_split")
    ->clear("use_category_parent")
    ->save();
}

/**
 * Create new view modes, display configurations and blocks.
 */
function social_tagging_update_12001() : void {
  // Should match list in social_tagging_update_12000.
  $entity_types = [
    'node' => [
      'book',
      'event',
      'page',
      'topic',
      'landing_page',
    ],
    'group' => [
      'flexible_group',
      'secret_group',
      'closed_group',
      'open_group',
      'public_group',
    ],
    'profile' => [
      'profile',
    ],
  ];

  foreach ($entity_types as $entity_type => $bundles) {
    EntityViewMode::create([
      'langcode' => 'en',
      'status' => TRUE,
      'dependencies' => [
        'module' => [
          'social_tagging',
          $entity_type,
        ],
      ],
      'id' => "${entity_type}.social_tagging",
      'label' => 'Tags',
      'targetEntityType' => $entity_type,
      'cache' => TRUE,
    ])->save();
    foreach ($bundles as $bundle) {
      EntityViewDisplay::create([
        'langcode' => 'en',
        'status' => TRUE,
        'dependencies' => [
          'config' => [
            "core.entity_view_mode.${entity_type}.social_tagging",
            "field.field.${entity_type}.${bundle}.field_social_tagging",
            "${entity_type}.type.${bundle}",
          ],
          'module' => [
            'social_tagging',
          ],
        ],
        'id' => "${entity_type}.${bundle}.social_tagging",
        'targetEntityType' => $entity_type,
        'bundle' => $bundle,
        'mode' => 'social_tagging',
        'content' => [
          'field_social_tagging' => [
            'type' => 'social_tag_split',
            'weight' => 0,
            'region' => 'content',
            'label' => 'hidden',
            'settings' => [
              'allow_category_parent_selection' => TRUE,
            ],
            'third_party_settings' => [],
          ],
          'hidden' => [],
        ],
      ])->save();
    }
  }

  // If the block doesn't exist we skip it, this means it was deleted
  // consciously by a site builder.
  $content_block = Block::load("socialtagsblock");
  if ($content_block !== NULL) {
    $content_block->set("plugin", "entity_view_block");
    $content_block_settings = $content_block->get("settings");
    $content_block_settings["id"] = "entity_view_block";
    $content_block_settings["provider"] = "social_core";
    $content_block_settings["view_mode"] = "social_tagging";
    $content_block_settings["context_mapping"] = ["entity" => '@social_core.entity_route_context:canonical_content_entity'];
    $content_block->set("settings", $content_block_settings);
    $content_block->save();
  }

  // Create the new block if the old one existed.
  // If the old one doesn't exist then the current installation probably doesn't
  // want the new one either.
  $group_block = Block::load("socialgrouptagsblock");
  if ($group_block !== NULL) {
    $new_group_block = [
      "dependencies" => [
        "langcode" => "en",
        "status" => TRUE,
        "module" => [
          "social_core",
          "system",
        ],
        "theme" => [
          "socialblue",
        ],
        "enforced" => [
          "module" => [
            "social_tagging",
          ],
        ],
      ],
      "id" => "socialblue_grouptagsblock",
      "theme" => $group_block->get("theme"),
      "region" => $group_block->get("region"),
      "weight" => $group_block->get("weight"),
      "plugin" => "entity_view_block",
      "settings" => [
        "id" => "entity_view_block",
        "label" => 'Group Tags',
        "label_display" => "visible",
        "provider" => "social_core",
        "view_mode" => "social_tagging",
        "context_mapping" => [
          "entity" => '@social_core.entity_route_context:canonical_content_entity',
        ],
      ],
      "visibility" => $group_block->get("visibility"),
    ];
    $group_block->delete();
    Block::create($new_group_block)->save();
  }

}


// TODO: Move to fieldable field using config/optional for `group`/`node`/`profile`
// TODO: Add an aggregated field to the search index which unions the term ID and name
// TODO: Update the views to filter on this field.
// TODO: Add update hooks for the above and migrate data from the current base field.
// TODO: Check the term ID type
