<?php

/**
 * @file
 * Enhances the token API in core: adds a browseable UI, missing tokens, etc.
 */

use Drupal\Component\Render\PlainTextOutput;
use Drupal\Component\Utility\SafeMarkup;
use Drupal\Component\Utility\Unicode;
use Drupal\Component\Utility\Xss;
use Drupal\Core\Block\BlockPluginInterface;
use Drupal\Core\Cache\Cache;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Render\Element;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Utility\Token;
use Drupal\Core\Url;

/**
 * Implements hook_help().
 */
function token_help($route_name, RouteMatchInterface $route_match) {
  if ($route_name == 'help.page.token') {
    $token_tree = \Drupal::service('token.tree_builder')->buildAllRenderable([
      'click_insert' => FALSE,
      'show_restricted' => TRUE,
    ]);

    $output = '<dl>';
    $output .= '<dt>' . t('List of the currently available tokens on this site') . '</dt>';
    $output .= '<dd>' . \Drupal::service('renderer')->render($token_tree) . '</dd>';
    $output .= '</dl>';
    return $output;
  }
}

/**
 * Return an array of the core modules supported by token.module.
 */
function _token_core_supported_modules() {
  return array('book', 'field', 'menu_ui');
}

/**
 * Implements hook_theme().
 */
function token_theme() {
  $info['token_tree_link'] = [
    'variables' => [
      'token_types' => [],
      'global_types' => TRUE,
      'click_insert' => TRUE,
      'show_restricted' => FALSE,
      'recursion_limit' => 3,
      'text' => NULL,
      'options' => [],
    ],
    'file' => 'token.pages.inc',
  ];

  return $info;
}

/**
 * Implements hook_block_view_alter().
 */
function token_block_view_alter(&$build, BlockPluginInterface $block) {
  $label = $build['#configuration']['label'];
  if ($label != '<none>') {
    // The label is automatically escaped, avoid escaping it twice.
    // @todo https://www.drupal.org/node/2580723 will add a method or option
    //   to the token API to do this, use that when available.
    $build['#configuration']['label'] = PlainTextOutput::renderFromHtml(\Drupal::token()->replace($label, array()));
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function token_form_block_form_alter(&$form, FormStateInterface $form_state) {
  $form['settings']['label']['#description'] = t('This field supports tokens.');
  $form['settings']['label']['#element_validate'][] = 'token_element_validate';
  $form['settings']['label'] += array('#token_types' => array());
}

/**
 * Implements hook_field_info_alter().
 */
function token_field_info_alter(&$info) {
  $defaults = array(
    'taxonomy_term_reference' => 'taxonomy_term_reference_plain',
    'number_integer' => 'number_unformatted',
    'number_decimal' => 'number_unformatted',
    'number_float' => 'number_unformatted',
    'file' => 'file_url_plain',
    'image' => 'file_url_plain',
    'text' => 'text_default',
    'text_long' => 'text_default',
    'text_with_summary' => 'text_default',
    'list_integer' => 'list_default',
    'list_float' => 'list_default',
    'list_string' => 'list_default',
    'list_boolean' => 'list_default',
  );
  foreach ($defaults as $field_type => $default_token_formatter) {
    if (isset($info[$field_type])) {
      $info[$field_type] += array('default_token_formatter' => $default_token_formatter);
    }
  }
}

/**
 * Implements hook_date_format_insert().
 */
function token_date_format_insert() {
  token_clear_cache();
}

/**
 * Implements hook_date_format_delete().
 */
function token_date_format_delete() {
  token_clear_cache();
}

/**
 * Implements hook_field_storage_config_presave().
 */
function token_field_config_presave($instance) {
  token_clear_cache();
}

/**
 * Implements hook_field_storage_config_delete().
 */
function token_field_config_delete($instance) {
  token_clear_cache();
}

/**
 * Clear token caches and static variables.
 */
function token_clear_cache() {
  \Drupal::token()->resetInfo();
  \Drupal::service('token.entity_mapper')->resetInfo();
  drupal_static_reset('token_menu_link_load_all_parents');
  drupal_static_reset('token_book_link_load');
}

/**
 * Implements hook_entity_type_alter().
 *
 * Because some token types to do not match their entity type names, we have to
 * map them to the proper type. This is purely for other modules' benefit.
 *
 * @see \Drupal\token\TokenEntityMapperInterface::getEntityTypeMappings()
 * @see http://drupal.org/node/737726
 */
function token_entity_type_alter(array &$entity_types) {
  $devel_exists = \Drupal::moduleHandler()->moduleExists('devel');
  /* @var $entity_types \Drupal\Core\Entity\EntityTypeInterface[] */
  foreach ($entity_types as $entity_type_id => $entity_type) {
    if (!$entity_type->get('token_type')) {
      // Fill in default token types for entities.
      switch ($entity_type_id) {
        case 'taxonomy_term':
        case 'taxonomy_vocabulary':
          // Stupid taxonomy token types...
          $entity_type->set('token_type', str_replace('taxonomy_', '', $entity_type_id));
          break;

        default:
          // By default the token type is the same as the entity type.
          $entity_type->set('token_type', $entity_type_id);
          break;
      }
    }

    if ($devel_exists
      && $entity_type->hasViewBuilderClass()
      && ($canonical = $entity_type->getLinkTemplate('canonical'))
      && !$entity_type->hasLinkTemplate('token-devel')) {
      $entity_type->setLinkTemplate('token-devel', $canonical . '/devel/token');
    }
  }
}

/**
 * Implements hook_entity_view_modes_info().
 */

/**
 * Implements hook_module_implements_alter().
 *
 * Adds missing token support for core modules.
 */
function token_module_implements_alter(&$implementations, $hook) {
  module_load_include('inc', 'token', 'token.tokens');

  if ($hook == 'tokens' || $hook == 'token_info' || $hook == 'token_info_alter' || $hook == 'tokens_alter') {
    foreach (_token_core_supported_modules() as $module) {
      if (\Drupal::moduleHandler()->moduleExists($module) && function_exists($module . '_' . $hook)) {
        $implementations[$module] = TRUE;
      }
    }
    // Move token.module to get included first since it is responsible for
    // other modules.
    if (isset($implementations['token'])) {
      unset($implementations['token']);
      $implementations = array_merge(array('token' => 'tokens'), $implementations);
    }
  }
}

/**
 * Return the module responsible for a token.
 *
 * @param string $type
 *   The token type.
 * @param string $name
 *   The token name.
 *
 * @return mixed
 *   The value of $info['tokens'][$type][$name]['module'] from token info, or
 *   NULL if the value does not exist.
 */
function _token_module($type, $name) {
  $token_info = \Drupal::token()->getTokenInfo($type, $name);
  return isset($token_info['module']) ? $token_info['module'] : NULL;
}

/**
 * Validate a form element that should have tokens in it.
 *
 * Form elements that want to add this validation should have the #token_types
 * parameter defined.
 *
 * For example:
 * @code
 * $form['my_node_text_element'] = array(
 *   '#type' => 'textfield',
 *   '#title' => t('Some text to token-ize that has a node context.'),
 *   '#default_value' => 'The title of this node is [node:title].',
 *   '#element_validate' => array('token_element_validate'),
 *   '#token_types' => array('node'),
 *   '#min_tokens' => 1,
 *   '#max_tokens' => 10,
 * );
 * @endcode
 */
function token_element_validate($element, FormStateInterface $form_state) {
  $value = isset($element['#value']) ? $element['#value'] : $element['#default_value'];

  if (!Unicode::strlen($value)) {
    // Empty value needs no further validation since the element should depend
    // on using the '#required' FAPI property.
    return $element;
  }

  $tokens = \Drupal::token()->scan($value);
  $title = empty($element['#title']) ? $element['#parents'][0] : $element['#title'];
  // @todo Find old Drupal 6 style tokens and add them to invalid tokens.

  // Validate if an element must have a minimum number of tokens.
  if (isset($element['#min_tokens']) && count($tokens) < $element['#min_tokens']) {
    // @todo Change this error message to include the minimum number.
    $error = \Drupal::translation()->formatPlural($element['#min_tokens'], 'The %element-title must contain at least one token.', 'The %element-title must contain at least @count tokens.', array('%element-title' => $title));
    $form_state->setError($element, $error);
  }

  // Validate if an element must have a maximum number of tokens.
  if (isset($element['#max_tokens']) && count($tokens) > $element['#max_tokens']) {
    // @todo Change this error message to include the maximum number.
    $error = \Drupal::translation()->formatPlural($element['#max_tokens'], 'The %element-title must contain as most one token.', 'The %element-title must contain at most @count tokens.', array('%element-title' => $title));
    $form_state->setError($element, $error);
  }

  // Check if the field defines specific token types.
  if (isset($element['#token_types'])) {
    $invalid_tokens = \Drupal::token()->getInvalidTokensByContext($tokens, $element['#token_types']);
    if ($invalid_tokens) {
      $form_state->setError($element, t('The %element-title is using the following invalid tokens: @invalid-tokens.', array('%element-title' => $title, '@invalid-tokens' => implode(', ', $invalid_tokens))));
    }
  }

  return $element;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function token_form_field_config_edit_form_alter(&$form, FormStateInterface $form_state) {
  $field_config = $form_state->getFormObject()->getEntity();
  $field_storage = $field_config->getFieldStorageDefinition();
  if ($field_storage->isLocked()) {
    return;
  }
  $field_type = $field_storage->getType();
  if (($field_type == 'file' || $field_type == 'image') && isset($form['settings']['file_directory'])) {
    // GAH! We can only support global tokens in the upload file directory path.
    $form['settings']['file_directory']['#element_validate'][] = 'token_element_validate';
    // Date support needs to be implicitly added, as while technically it's not
    // a global token, it is a not only used but is the default value.
    // https://www.drupal.org/node/2642160
    $form['settings']['file_directory'] += array('#token_types' => array('date'));
    $form['settings']['file_directory']['#description'] .= ' ' . t('This field supports tokens.');
  }

  // Note that the description is tokenized via token_field_widget_form_alter().
  $form['description']['#element_validate'][] = 'token_element_validate';
  $form['description'] += array('#token_types' => array());

  $form['token_tree'] = array(
    '#theme' => 'token_tree_link',
    '#token_types' => array(),
    '#weight' => $form['description']['#weight'] + 0.5,
  );
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Alters the configure action form to add token context validation and
 * adds the token tree for a better token UI and selection.
 */
function token_form_action_add_form_alter(&$form, $form_state) {
  switch ($form['plugin']['#value']) {
    case 'action_message_action':
    case 'action_send_email_action':
    case 'action_goto_action':
      $form['token_tree'] = [
        '#theme' => 'token_tree_link',
        '#token_types' => 'all',
        '#weight' => 100,
      ];
      $form['actions']['#weight'] = 101;
      // @todo Add token validation to the action fields that can use tokens.
      break;
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Alters the user e-mail fields to add token context validation and
 * adds the token tree for a better token UI and selection.
 */
function token_form_user_admin_settings_alter(&$form, FormStateInterface $form_state) {
  $email_token_help = t('Available variables are: [site:name], [site:url], [user:display-name], [user:account-name], [user:mail], [site:login-url], [site:url-brief], [user:edit-url], [user:one-time-login-url], [user:cancel-url].');

  foreach (Element::children($form) as $key) {
    $element = &$form[$key];

    // Remove the crummy default token help text.
    if (!empty($element['#description'])) {
      $element['#description'] = trim(str_replace($email_token_help, t('The list of available tokens that can be used in e-mails is provided below.'), $element['#description']));
    }

    switch ($key) {
      case 'email_admin_created':
      case 'email_pending_approval':
      case 'email_no_approval_required':
      case 'email_password_reset':
      case 'email_cancel_confirm':
        // Do nothing, but allow execution to continue.
        break;
      case 'email_activated':
      case 'email_blocked':
      case 'email_canceled':
        // These fieldsets have their e-mail elements inside a 'settings'
        // sub-element, so switch to that element instead.
        $element = &$form[$key]['settings'];
        break;
      default:
        continue 2;
    }

    foreach (Element::children($element) as $sub_key) {
      if (!isset($element[$sub_key]['#type'])) {
        continue;
      }
      elseif ($element[$sub_key]['#type'] == 'textfield' && substr($sub_key, -8) === '_subject') {
        // Add validation to subject textfields.
        $element[$sub_key]['#element_validate'][] = 'token_element_validate';
        $element[$sub_key] += array('#token_types' => array('user'));
      }
      elseif ($element[$sub_key]['#type'] == 'textarea' && substr($sub_key, -5) === '_body') {
        // Add validation to body textareas.
        $element[$sub_key]['#element_validate'][] = 'token_element_validate';
        $element[$sub_key] += array('#token_types' => array('user'));
      }
    }
  }

  // Add the token tree UI.
  $form['email']['token_tree'] = array(
    '#theme' => 'token_tree_link',
    '#token_types' => array('user'),
    '#show_restricted' => TRUE,
    '#weight' => 90,
  );
}

/**
 * Get a translated book menu link by its mlid, without access checking.
 *
 * This function is a copy of book_link_load() but with its own cache and a
 * simpler query to load the link. This also skips normal menu link access
 * checking by using _token_menu_link_translate().
 *
 * @param $mlid
 *   The mlid of the book menu item.
 *
 * @return
 *   A book menu link translated for rendering.
 *
 * @see book_link_load()
 * @see _token_menu_link_translate()
 */
function token_book_link_load($mlid) {
  $cache = &drupal_static(__FUNCTION__, array());

  if (!is_numeric($mlid)) {
    return FALSE;
  }

  if (!isset($cache[$mlid])) {
    $item = db_query("SELECT * FROM {menu_links} ml INNER JOIN {book} b ON b.mlid = ml.mlid LEFT JOIN {menu_router} m ON m.path = ml.router_path WHERE ml.mlid = :mlid", array(':mlid' => $mlid))->fetchAssoc();
    if (!empty($item)) {
      _token_menu_link_translate($item);
    }
    $cache[$mlid] = $item;
  }

  return $cache[$mlid];
}

function _token_menu_link_translate(&$item) {
  $map = array();

  if (!is_array($item['options'])) {
    $item['options'] = unserialize($item['options']);
  }

  if ($item['external']) {
    $item['access'] = 1;
    $item['href'] = $item['link_path'];
    $item['title'] = $item['link_title'];
    $item['localized_options'] = $item['options'];
  }
  else {
    // Complete the path of the menu link with elements from the current path,
    // if it contains dynamic placeholders (%).
    $map = explode('/', $item['link_path']);
    if (strpos($item['link_path'], '%') !== FALSE) {
      // Invoke registered to_arg callbacks.
      if (!empty($item['to_arg_functions'])) {
        _menu_link_map_translate($map, $item['to_arg_functions']);
      }
    }
    $item['href'] = implode('/', $map);

    // Skip links containing untranslated arguments.
    if (strpos($item['href'], '%') !== FALSE) {
      $item['access'] = FALSE;
      return FALSE;
    }

    $item['access'] = TRUE;
    _menu_item_localize($item, $map, TRUE);
  }

  // Allow other customizations - e.g. adding a page-specific query string to the
  // options array. For performance reasons we only invoke this hook if the link
  // has the 'alter' flag set in the options array.
  if (!empty($item['options']['alter'])) {
    \Drupal::moduleHandler()->alter('translated_menu_link', $item, $map);
  }

  return $map;
}

/**
 * Prepare a string for use as a valid token name.
 *
 * @param $name
 *   The token name to clean.
 * @return
 *   The cleaned token name.
 */
function token_clean_token_name($name) {
  static $names = array();

  if (!isset($names[$name])) {
    $cleaned_name = strtr($name, array(' ' => '-', '_' => '-', '/' => '-', '[' => '-', ']' => ''));
    $cleaned_name = preg_replace('/[^\w\-]/i', '', $cleaned_name);
    $cleaned_name = trim($cleaned_name, '-');
    $names[$name] = $cleaned_name;
  }

  return $names[$name];
}

/**
 * Do not use this function yet. Its API has not been finalized.
 */
function token_render_array(array $array, array $options = array()) {
  $rendered = array();

  /** @var \Drupal\Core\Render\RendererInterface $renderer */
  $renderer = \Drupal::service('renderer');

  foreach (token_element_children($array) as $key) {
    $value = $array[$key];
    $rendered[] = is_array($value) ? $renderer->renderPlain($value) : (string) $value;
  }
  $join = isset($options['join']) ? $options['join'] : ', ';
  return implode($join, $rendered);
}

/**
 * Do not use this function yet. Its API has not been finalized.
 */
function token_render_array_value($value, array $options = array()) {
  /** @var \Drupal\Core\Render\RendererInterface $renderer */
  $renderer = \Drupal::service('renderer');

  $rendered = is_array($value) ? $renderer->renderPlain($value) : (string) $value;
  return $rendered;
}

/**
 * Copy of drupal_render_cache_get() that does not care about request method.
 */
function token_render_cache_get($elements) {
  if (!$cid = drupal_render_cid_create($elements)) {
    return FALSE;
  }
  $bin = isset($elements['#cache']['bin']) ? $elements['#cache']['bin'] : 'render';

  if (!empty($cid) && $cache = \Drupal::cache($bin)->get($cid)) {
    // Add additional libraries, JavaScript, CSS and other data attached
    // to this element.
    if (isset($cache->data['#attached'])) {
      drupal_process_attached($cache->data);
    }
    // Return the rendered output.
    return $cache->data['#markup'];
  }
  return FALSE;
}

/**
 * Coyp of drupal_render_cache_set() that does not care about request method.
 */
function token_render_cache_set(&$markup, $elements) {
  // This should only run of drupal_render_cache_set() did not.
  if (in_array(\Drupal::request()->server->get('REQUEST_METHOD'), array('GET', 'HEAD'))) {
    return FALSE;
  }

  $original_method = \Drupal::request()->server->get('REQUEST_METHOD');
  \Drupal::request()->server->set('REQUEST_METHOD', 'GET');
  drupal_render_cache_set($markup, $elements);
  \Drupal::request()->server->set('REQUEST_METHOD', $original_method);
}

function token_menu_link_load_all_parents($plugin_id) {
  $cache = &drupal_static(__FUNCTION__, array());

  if (!isset($cache[$plugin_id])) {
    $cache[$plugin_id] = array();
    /** @var \Drupal\Core\Menu\MenuLinkManagerInterface $menu_link_manager */
    $menu_link_manager = \Drupal::service('plugin.manager.menu.link');
    $parent_ids = $menu_link_manager->getParentIds($plugin_id);
    // Remove the current plugin ID from the parents.
    unset($parent_ids[$plugin_id]);
    foreach ($parent_ids as $parent_id) {
      $parent = $menu_link_manager->createInstance($parent_id);
      $cache[$plugin_id] = array($parent_id => $parent->getTitle()) + $cache[$plugin_id];
    }
  }

  return $cache[$plugin_id];
}

function token_taxonomy_term_load_all_parents($tid) {
  $cache = &drupal_static(__FUNCTION__, array());

  if (!is_numeric($tid)) {
    return array();
  }

  if (!isset($cache[$tid])) {
    $cache[$tid] = array();
    /** @var \Drupal\taxonomy\TermStorageInterface $term_storage */
    $term_storage = \Drupal::entityManager()->getStorage('taxonomy_term');
    $parents = $term_storage->loadAllParents($tid);
    // Remove this term from the array.
    array_shift($parents);
    $parents = array_reverse($parents);
    foreach ($parents as $term) {
      $cache[$tid][$term->id()] = $term->label();
    }
  }

  return $cache[$tid];
}

function token_element_children(&$elements, $sort = FALSE) {
  // Do not attempt to sort elements which have already been sorted.
  $sort = isset($elements['#sorted']) ? !$elements['#sorted'] : $sort;

  // Filter out properties from the element, leaving only children.
  $children = array();
  $sortable = FALSE;
  foreach ($elements as $key => $value) {
    if ($key === '' || $key[0] !== '#') {
      $children[$key] = $value;
      if (is_array($value) && isset($value['#weight'])) {
        $sortable = TRUE;
      }
    }
  }
  // Sort the children if necessary.
  if ($sort && $sortable) {
    uasort($children, 'Drupal\Component\Utility\SortArray::sortByWeightProperty');
    // Put the sorted children back into $elements in the correct order, to
    // preserve sorting if the same element is passed through
    // element_children() twice.
    foreach ($children as $key => $child) {
      unset($elements[$key]);
      $elements[$key] = $child;
    }
    $elements['#sorted'] = TRUE;
  }

  return array_keys($children);
}
